# 페이징 처리 (Pagination)

## 개념

대량의 데이터를 **일정 단위로 나누어** 제공하는 기능

### 목적
- 서버 부하 감소
- 빠른 응답 속도
- 사용자 경험 향상

## 핵심 용어

| 용어 | 설명 | 예시 |
|------|------|------|
| 페이지 번호 (Page) | 현재 페이지 | 0, 1, 2... (0부터 시작) |
| 페이지 크기 (Size) | 페이지당 데이터 수 | 10, 20, 50 |
| 총 요소 수 (Total Elements) | 전체 데이터 수 | 95개 |
| 총 페이지 수 (Total Pages) | 전체 페이지 수 | 10개 (95 ÷ 10 = 9.5 → 10) |

## Spring Boot 구현

### 1. Repository
```java
public interface UserRepository extends JpaRepository {
    // 기본 페이징
    Page findAll(Pageable pageable);
    
    // 조건 + 페이징
    Page findByStatus(String status, Pageable pageable);
}
```

### 2. Service
```java
@Service
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    public Page getUsers(int page, int size) {
        Pageable pageable = PageRequest.of(page, size);
        return userRepository.findAll(pageable);
    }
}
```

### 3. Controller
```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @Autowired
    private UserService userService;
    
    @GetMapping
    public ResponseEntity<Map> getUsers(
        @RequestParam(defaultValue = "0") int page,
        @RequestParam(defaultValue = "10") int size
    ) {
        Page pageResult = userService.getUsers(page, size);
        
        Map response = new HashMap<>();
        response.put("content", pageResult.getContent());
        response.put("currentPage", pageResult.getNumber());
        response.put("totalElements", pageResult.getTotalElements());
        response.put("totalPages", pageResult.getTotalPages());
        
        return ResponseEntity.ok(response);
    }
}
```

### 4. 응답 예시
```json
{
  "content": [
    {"id": 1, "name": "홍길동"},
    {"id": 2, "name": "김철수"}
  ],
  "currentPage": 0,
  "totalElements": 95,
  "totalPages": 10
}
```

## 정렬 추가
```java
// 단일 정렬
Pageable pageable = PageRequest.of(
    0,                              // 페이지 번호
    10,                             // 페이지 크기
    Sort.by("createdDate").descending()  // 정렬
);

// 다중 정렬
Sort sort = Sort.by(
    Sort.Order.desc("createdDate"),
    Sort.Order.asc("name")
);
Pageable pageable = PageRequest.of(0, 10, sort);
```

### Controller에서 정렬
```java
@GetMapping
public Page getUsers(
    @RequestParam(defaultValue = "0") int page,
    @RequestParam(defaultValue = "10") int size,
    @RequestParam(defaultValue = "id") String sort
) {
    Pageable pageable = PageRequest.of(page, size, Sort.by(sort));
    return userService.getUsers(pageable);
}
```

**요청**:
```
GET /api/users?page=0&size=20&sort=name
```

## Page 객체 메서드
```java
Page page = userRepository.findAll(pageable);

page.getContent();           // 현재 페이지 데이터
page.getNumber();            // 현재 페이지 번호 (0부터)
page.getSize();              // 페이지 크기
page.getTotalElements();     // 전체 데이터 수
page.getTotalPages();        // 전체 페이지 수
page.isFirst();              // 첫 페이지 여부
page.isLast();               // 마지막 페이지 여부
page.hasNext();              // 다음 페이지 존재 여부
page.hasPrevious();          // 이전 페이지 존재 여부
```

## REST API 페이징

### 요청
```
GET /api/users?page=0&size=10
GET /api/users?page=1&size=20&sort=name,asc
```

### 응답 (표준)
```json
{
  "content": [...],
  "pageable": {
    "pageNumber": 0,
    "pageSize": 10
  },
  "totalElements": 95,
  "totalPages": 10,
  "last": false,
  "first": true
}
```

## Offset & Limit 방식

### SQL
```sql
SELECT * FROM users
ORDER BY id
LIMIT 10 OFFSET 20;  -- 21번째부터 10개
```

### Spring Data JPA
```java
Pageable pageable = PageRequest.of(2, 10);  // 3번째 페이지, 10개
// OFFSET = page * size = 2 * 10 = 20
```

## 커서 기반 페이징

대량 데이터에 효율적
```java
// 마지막 ID 기준으로 다음 페이지
@Query("SELECT u FROM User u WHERE u.id > :lastId ORDER BY u.id")
List findNextPage(@Param("lastId") Long lastId, Pageable pageable);
```

**요청**:
```
GET /api/users?lastId=100&size=20
```

**장점**: 데이터 추가/삭제 시에도 안정적

## 프론트엔드 구현

### JavaScript (Fetch)
```javascript
async function getUsers(page = 0, size = 10) {
  const response = await fetch(`/api/users?page=${page}&size=${size}`);
  const data = await response.json();
  
  displayUsers(data.content);
  displayPagination(data.currentPage, data.totalPages);
}

function displayPagination(current, total) {
  const pagination = document.getElementById('pagination');
  let html = '';
  
  for (let i = 0; i < total; i++) {
    html += `${i + 1}`;
  }
  
  pagination.innerHTML = html;
}
```

## 성능 최적화

### 1. 인덱스 활용
```sql
CREATE INDEX idx_created_date ON users(created_date);
```

### 2. 카운트 쿼리 최적화
```java
@Query(value = "SELECT u FROM User u",
       countQuery = "SELECT count(u) FROM User u")
Page findAllOptimized(Pageable pageable);
```

### 3. DTO 직접 조회
```java
@Query("SELECT new com.example.UserDto(u.id, u.name) FROM User u")
Page findAllDto(Pageable pageable);
```

## 주의사항

1. **페이지 번호는 0부터 시작**
```java
PageRequest.of(0, 10);  // 첫 페이지
```

2. **적절한 페이지 크기**
```
너무 작음: 요청 횟수 증가
너무 큼: 응답 느림
권장: 10~50
```

3. **대용량 데이터**
- Offset이 크면 느림
- 커서 기반 페이징 고려

## 참고 자료

- [Spring Data JPA Pagination](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.special-parameters)