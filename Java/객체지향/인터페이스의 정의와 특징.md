# 인터페이스

## 개념

구현 없이 메서드 시그니처만 정의하는 추상화된 설계도

**목적**: 구현을 강제하여 일관성 보장, 다중 구현 지원

## 기본 구조
```java
interface 인터페이스이름 {
    // 상수 (public static final 생략 가능)
    int MAX_VALUE = 100;
    
    // 추상 메서드 (public abstract 생략 가능)
    void method();
}
```

**특징**:
- 모든 필드는 `public static final` (상수)
- 모든 메서드는 `public abstract` (추상)
- 생략 가능 (컴파일러가 자동 추가)

## 구현 방식
```java
class 클래스명 implements 인터페이스명 {
    // 모든 추상 메서드 구현 필수
    @Override
    public void method() {
        // 구현
    }
}
```

**규칙**:
- `implements` 키워드 사용
- 모든 추상 메서드 구현 필수
- 미구현 시 컴파일 에러

## 인터페이스 vs 추상 클래스

| 구분 | 인터페이스 | 추상 클래스 |
|------|-----------|------------|
| 키워드 | interface | abstract class |
| 상속/구현 | 다중 구현 | 단일 상속 |
| 메서드 | 추상 메서드 (default, static 제외) | 추상 + 일반 메서드 |
| 변수 | 상수만 | 모든 변수 |
| 생성자 | 없음 | 있음 |
| 용도 | 기능 정의 | 공통 특성 |

## 다중 구현
```java
interface A {
    void methodA();
}

interface B {
    void methodB();
}

// 다중 구현 가능
class C implements A, B {
    public void methodA() { }
    public void methodB() { }
}
```

**장점**:
- 여러 기능 조합 가능
- 유연한 설계

## Java 8 이후 변화

### 1. default 메서드
```java
interface MyInterface {
    // 구현부 포함 가능
    default void defaultMethod() {
        System.out.println("기본 구현");
    }
}
```

**특징**:
- 인터페이스에 구현 메서드 추가
- 기존 구현 클래스 영향 없음
- 하위 호환성 유지

### 2. static 메서드
```java
interface MyInterface {
    static void staticMethod() {
        System.out.println("정적 메서드");
    }
}

// 사용
MyInterface.staticMethod();
```

**특징**:
- 인터페이스명으로 직접 호출
- 유틸리티 메서드 정의

## 주요 특징

### 1. 다형성 구현
```java
interface Animal {
    void sound();
}

class Dog implements Animal {
    public void sound() { System.out.println("멍멍"); }
}

class Cat implements Animal {
    public void sound() { System.out.println("야옹"); }
}

// 다형성
Animal animal = new Dog();
animal.sound();  // 멍멍
```

### 2. 결합도 감소
```java
// 인터페이스 의존 (느슨한 결합)
interface PaymentService {
    void pay(int amount);
}

class CreditCard implements PaymentService {
    public void pay(int amount) { }
}

class KakaoPay implements PaymentService {
    public void pay(int amount) { }
}
```

**장점**:
- 구현체 변경 용이
- 테스트 쉬움 (Mock 사용)

### 3. 강제 규약
```java
interface Comparable {
    int compareTo(Object o);
}

// 구현 강제
class Student implements Comparable {
    public int compareTo(Object o) {
        // 반드시 구현
    }
}
```

## 정리

**인터페이스 사용 이유**:
- 다중 구현
- 결합도 감소
- 일관성 보장
- 유연한 설계

**사용 시기**:
- 공통 기능 정의
- 다형성 필요
- 느슨한 결합 원할 때

## 참고 자료

- [Oracle Interface 가이드](https://docs.oracle.com/javase/tutorial/java/IandI/createinterface.html)