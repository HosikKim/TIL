# 캡슐화 (Encapsulation)

## 개념

데이터와 메서드를 하나로 묶고 외부 접근을 제한하는 것

**목적**: 데이터 보호, 무결성 유지, 내부 구현 은닉

## 구현 방법
```java
public class Product {
    // private으로 데이터 은닉
    private String productId;
    private int price;
    
    // getter - 읽기
    public String getProductId() {
        return productId;
    }
    
    // setter - 쓰기 (검증 포함)
    public void setPrice(int price) {
        if (price < 0) {
            this.price = 0;  // 잘못된 값 방지
        } else {
            this.price = price;
        }
    }
}

// 사용
Product product = new Product();
// product.price = -1000;  // ❌ 직접 접근 불가
product.setPrice(-1000);    // ✅ 검증 후 0으로 설정
```

## 접근 제어자

| 제어자 | 클래스 내 | 같은 패키지 | 하위 클래스 | 다른 패키지 |
|--------|----------|------------|------------|------------|
| public | ✅ | ✅ | ✅ | ✅ |
| protected | ✅ | ✅ | ✅ | ❌ |
| default | ✅ | ✅ | ❌ | ❌ |
| private | ✅ | ❌ | ❌ | ❌ |

## 캡슐화 전후 비교

### 캡슐화 전
```java
class BankAccount {
    public int balance;  // 외부 노출
}

// 문제 발생
BankAccount account = new BankAccount();
account.balance = -1000;  // 잘못된 값 설정 가능
```

### 캡슐화 후
```java
class BankAccount {
    private int balance;  // 은닉
    
    public void deposit(int amount) {
        if (amount > 0) {
            balance += amount;
        }
    }
    
    public boolean withdraw(int amount) {
        if (amount > 0 && balance >= amount) {
            balance -= amount;
            return true;
        }
        return false;
    }
    
    public int getBalance() {
        return balance;
    }
}

// 안전한 사용
BankAccount account = new BankAccount();
account.deposit(1000);
account.withdraw(500);
```


## 장점

### 1. 데이터 보호
- 잘못된 값 설정 방지
- 객체 상태 일관성 유지

### 2. 유지보수 용이
- 내부 구현 변경 시 외부 영향 최소화
- getter/setter만 수정

### 3. 사용 편의성
- 복잡한 로직 은닉
- 간단한 인터페이스 제공

## 정리

**캡슐화 원칙**:
- 필드는 private
- getter/setter로 접근
- 검증 로직 포함

**핵심**:
- 데이터 보호
- 무결성 유지
- 변경 영향 최소화

## 참고 자료

- [Oracle Encapsulation](https://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html)