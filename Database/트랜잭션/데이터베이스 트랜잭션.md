# 데이터베이스 트랜잭션 (Transaction)

## 개념

데이터베이스 작업의 **논리적 단위**로, 여러 연산을 하나로 묶어 처리

### 목적
- 데이터 일관성 보장
- 오류 시 복구 가능
- 동시성 제어

## ACID 원칙

### 1. 원자성 (Atomicity)

**All or Nothing**: 모두 성공 또는 모두 실패
```sql
-- 계좌 이체 예시
START TRANSACTION;

UPDATE accounts SET balance = balance - 10000 WHERE account_id = 1;  -- 출금
UPDATE accounts SET balance = balance + 10000 WHERE account_id = 2;  -- 입금

-- 둘 다 성공 → COMMIT
-- 하나라도 실패 → ROLLBACK (모두 취소)
COMMIT;
```

**보장**:
- 중간 실패 시 모든 변경 취소
- 부분 완료 상태 존재하지 않음

### 2. 일관성 (Consistency)

**트랜잭션 전후 데이터 무결성 유지**
```sql
-- 제약조건 위반 시 자동 롤백
START TRANSACTION;

INSERT INTO orders (customer_id) VALUES (999);  
-- customer_id=999 없으면 FK 제약조건 위반 → 자동 ROLLBACK

COMMIT;
```

**보장**:
- 제약조건 만족
- 비즈니스 규칙 준수

### 3. 격리성 (Isolation)

**동시 실행 트랜잭션 간 독립성**
```sql
-- 트랜잭션 A
START TRANSACTION;
SELECT balance FROM accounts WHERE account_id = 1;  -- 10000
-- ... 처리 중 ...

-- 트랜잭션 B (동시 실행)
START TRANSACTION;
UPDATE accounts SET balance = 5000 WHERE account_id = 1;
COMMIT;

-- 트랜잭션 A
-- 격리 수준에 따라 10000 또는 5000 보임
COMMIT;
```

### 4. 지속성 (Durability)

**완료된 트랜잭션은 영구 저장**
```sql
COMMIT;  -- 완료 후 시스템 장애 발생해도 데이터 유지
```

**보장**:
- 커밋 후 데이터 손실 없음
- 로그 파일에 기록

## 트랜잭션 제어 (TCL)

### 기본 명령어
```sql
-- 트랜잭션 시작
START TRANSACTION;  -- 또는 BEGIN;

-- 작업 수행
INSERT INTO users VALUES (1, 'Kim');
UPDATE products SET stock = stock - 1 WHERE id = 10;

-- 확정
COMMIT;  -- 변경사항 영구 저장

-- 또는 취소
ROLLBACK;  -- 모든 변경사항 취소
```

### SAVEPOINT
```sql
START TRANSACTION;

INSERT INTO users VALUES (1, 'Kim');
SAVEPOINT sp1;  -- 저장점 생성

UPDATE users SET name = 'Lee' WHERE id = 1;
SAVEPOINT sp2;

DELETE FROM users WHERE id = 1;

-- sp2로 돌아가기
ROLLBACK TO sp2;  -- DELETE만 취소, UPDATE는 유지

-- sp1으로 돌아가기
ROLLBACK TO sp1;  -- UPDATE, DELETE 모두 취소, INSERT는 유지

COMMIT;
```

## 격리 수준 (Isolation Level)

| 수준 | Dirty Read | Non-Repeatable Read | Phantom Read | 성능 |
|------|-----------|---------------------|--------------|------|
| READ UNCOMMITTED | O | O | O | 빠름 ⭐⭐⭐ |
| READ COMMITTED | X | O | O | 중간 ⭐⭐ |
| REPEATABLE READ | X | X | O | 느림 ⭐ |
| SERIALIZABLE | X | X | X | 매우 느림 |

### 격리 수준 설정
```sql
-- 세션 레벨
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;

-- 트랜잭션 레벨
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
START TRANSACTION;
-- ...
COMMIT;
```

### 격리 수준 별 문제

#### 1. Dirty Read (READ UNCOMMITTED)
```sql
-- 트랜잭션 A
UPDATE accounts SET balance = 5000 WHERE id = 1;
-- 아직 COMMIT 안 함

-- 트랜잭션 B
SELECT balance FROM accounts WHERE id = 1;  -- 5000 읽음 (커밋 안 된 데이터)

-- 트랜잭션 A
ROLLBACK;  -- 트랜잭션 B가 읽은 데이터는 무효
```

#### 2. Non-Repeatable Read (READ COMMITTED)
```sql
-- 트랜잭션 A
SELECT balance FROM accounts WHERE id = 1;  -- 10000

-- 트랜잭션 B
UPDATE accounts SET balance = 5000 WHERE id = 1;
COMMIT;

-- 트랜잭션 A
SELECT balance FROM accounts WHERE id = 1;  -- 5000 (값이 바뀜)
```

#### 3. Phantom Read (REPEATABLE READ)
```sql
-- 트랜잭션 A
SELECT COUNT(*) FROM users WHERE age > 20;  -- 100명

-- 트랜잭션 B
INSERT INTO users VALUES (101, 'Kim', 25);
COMMIT;

-- 트랜잭션 A
SELECT COUNT(*) FROM users WHERE age > 20;  -- 101명 (새 행 추가됨)
```

## 트랜잭션 상태
```
[활성] → [부분 커밋] → [커밋됨]
  ↓
[실패] → [중단됨] → [종료]
```

1. **활성 (Active)**: 실행 중
2. **부분 커밋 (Partially Committed)**: 마지막 연산 완료, 아직 커밋 전
3. **커밋됨 (Committed)**: 성공적 완료
4. **실패 (Failed)**: 정상 실행 불가
5. **중단됨 (Aborted)**: 롤백 완료

## 실전 예시

### 계좌 이체
```sql
START TRANSACTION;

-- 출금 계좌 잔액 확인
SELECT balance INTO @balance FROM accounts WHERE id = 1;

IF @balance >= 10000 THEN
    -- 출금
    UPDATE accounts SET balance = balance - 10000 WHERE id = 1;
    
    -- 입금
    UPDATE accounts SET balance = balance + 10000 WHERE id = 2;
    
    -- 거래 내역 기록
    INSERT INTO transactions (from_account, to_account, amount) 
    VALUES (1, 2, 10000);
    
    COMMIT;
ELSE
    ROLLBACK;
    SELECT '잔액 부족' AS error;
END IF;
```

### 재고 감소
```sql
START TRANSACTION;

-- 재고 확인
SELECT stock INTO @stock FROM products WHERE id = 100;

IF @stock >= 5 THEN
    -- 재고 차감
    UPDATE products SET stock = stock - 5 WHERE id = 100;
    
    -- 주문 생성
    INSERT INTO orders (product_id, quantity) VALUES (100, 5);
    
    COMMIT;
ELSE
    ROLLBACK;
END IF;
```

## 트랜잭션 관리 방식

### 1. 명시적 관리 (SQL)
```sql
START TRANSACTION;
-- SQL 문들
COMMIT;
```

### 2. 자동 커밋 (Auto-commit)
```sql
-- MySQL 기본값: 자동 커밋 ON
SET autocommit = 0;  -- 자동 커밋 OFF
```

### 3. 프로그래밍 (Java 예시)
```java
// JDBC
connection.setAutoCommit(false);
try {
    // 작업 수행
    connection.commit();
} catch (Exception e) {
    connection.rollback();
}

// Spring
@Transactional
public void transferMoney(int from, int to, int amount) {
    // 자동으로 트랜잭션 관리
}
```

## 주의사항

1. **트랜잭션 최소화**: 필요한 작업만 포함
2. **데드락 방지**: 일관된 순서로 자원 접근
3. **타임아웃 설정**: 무한 대기 방지
4. **적절한 격리 수준**: 성능과 일관성 균형

## 참고 자료

- [MySQL Transaction](https://dev.mysql.com/doc/refman/8.0/en/commit.html)
- [PostgreSQL Transaction](https://www.postgresql.org/docs/current/tutorial-transactions.html)