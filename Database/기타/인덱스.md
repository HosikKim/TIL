# 인덱스 (Index)

## 개념

데이터베이스 테이블의 **검색 속도를 향상**시키기 위한 자료구조

### 비유
- 책의 목차/색인과 유사
- 특정 데이터를 빠르게 찾기 위한 지름길

### 특징
- 별도의 저장 공간 필요
- 검색 성능 향상 ⬆️
- 삽입/수정/삭제 성능 저하 ⬇️

## 인덱스 동작 원리

### 인덱스 없이 검색 (Full Table Scan)
```sql
SELECT * FROM users WHERE name = '홍길동';
-- 100만 건 → 100만 건 모두 검색 (O(n))
```

### 인덱스 사용
```sql
CREATE INDEX idx_name ON users(name);
SELECT * FROM users WHERE name = '홍길동';
-- 100만 건 → 약 20번 비교로 검색 (O(log n))
```

## 인덱스 구조

### B-Tree 인덱스 (가장 일반적)
```
        [김철수, 이영희]
       /       |       \
   [강감찬] [김유신] [박찬호]
     |        |        |
   데이터   데이터    데이터
```

**특징**:
- 균형 잡힌 트리 구조
- 범위 검색 효율적
- 대부분의 DBMS 기본 인덱스

**시간 복잡도**: O(log n)

### Hash 인덱스
```
hash('홍길동') → 12345 → 데이터 위치
```

**특징**:
- 해시 함수로 위치 계산
- 등가 비교(=)만 가능
- 범위 검색 불가

**시간 복잡도**: O(1)

## 인덱스 종류

### 1. 클러스터드 인덱스 (Clustered Index)

**정의**: 데이터가 **물리적으로 정렬**되어 저장
```sql
-- PK는 자동으로 클러스터드 인덱스
CREATE TABLE users (
    id INT PRIMARY KEY,  -- 클러스터드 인덱스
    name VARCHAR(50)
);
```

**특징**:
- 테이블당 **1개만** 생성 가능
- 데이터가 정렬되어 저장
- 범위 검색 빠름
- PK에 자동 생성

**장점**: 검색 속도 빠름
**단점**: 삽입/수정 시 물리적 재정렬

### 2. 논클러스터드 인덱스 (Non-Clustered Index)

**정의**: 별도의 인덱스 공간에 저장
```sql
CREATE INDEX idx_name ON users(name);  -- 논클러스터드
CREATE INDEX idx_email ON users(email);
```

**특징**:
- 테이블당 **여러 개** 생성 가능
- 데이터는 그대로, 인덱스만 별도 저장
- 인덱스 → 데이터 2단계 접근

### 클러스터드 vs 논클러스터드

| 구분 | 클러스터드 | 논클러스터드 |
|------|-----------|-------------|
| 개수 | 테이블당 1개 | 여러 개 가능 |
| 정렬 | 물리적 정렬 | 논리적 정렬 |
| 속도 | 빠름 | 상대적으로 느림 |
| 공간 | 적음 | 많음 (별도 공간) |
| 생성 | PK 자동 | 수동 생성 |

## 인덱스 생성

### 단일 컬럼 인덱스
```sql
CREATE INDEX idx_name ON users(name);

-- 사용
SELECT * FROM users WHERE name = '홍길동';  -- 인덱스 사용 ✅
```

### 복합 인덱스 (다중 컬럼)
```sql
CREATE INDEX idx_name_age ON users(name, age);

-- 인덱스 사용 O
SELECT * FROM users WHERE name = '홍길동' AND age = 25;  ✅
SELECT * FROM users WHERE name = '홍길동';  ✅ (첫 번째 컬럼)

-- 인덱스 사용 X
SELECT * FROM users WHERE age = 25;  ❌ (두 번째 컬럼만)
```

**규칙**: 복합 인덱스는 **왼쪽부터** 사용

### 유니크 인덱스
```sql
CREATE UNIQUE INDEX idx_email ON users(email);
-- 중복 값 불가
```

### 전문 검색 인덱스 (Full-Text Index)
```sql
CREATE FULLTEXT INDEX idx_content ON posts(content);

-- 사용
SELECT * FROM posts WHERE MATCH(content) AGAINST('검색어');
```

## 인덱스 관리

### 인덱스 조회
```sql
-- MySQL
SHOW INDEX FROM users;

-- 특정 쿼리의 인덱스 사용 확인
EXPLAIN SELECT * FROM users WHERE name = '홍길동';
```

### 인덱스 삭제
```sql
DROP INDEX idx_name ON users;

-- 또는
ALTER TABLE users DROP INDEX idx_name;
```

### 인덱스 재생성
```sql
-- 인덱스 단편화 해소
ALTER TABLE users DROP INDEX idx_name;
CREATE INDEX idx_name ON users(name);

-- MySQL 8.0+
ALTER TABLE users ALGORITHM=INPLACE, LOCK=NONE, REBUILD;
```

## 인덱스 성능

### 장점

| 장점 | 효과 |
|------|------|
| 검색 속도 | 대폭 향상 (O(n) → O(log n)) |
| 정렬 속도 | ORDER BY 성능 향상 |
| MIN/MAX | 빠른 집계 |
| 고유성 보장 | UNIQUE 제약 |

### 단점

| 단점 | 영향 |
|------|------|
| 저장 공간 | DB 크기 증가 (약 10%) |
| INSERT | 인덱스 갱신으로 느려짐 |
| UPDATE | 인덱스 키 변경 시 느려짐 |
| DELETE | 인덱스 갱신으로 느려짐 |

### 성능 비교
```sql
-- 인덱스 없음
SELECT * FROM users WHERE age = 25;
-- 100만 건 → 100만 건 검색 (약 1초)

-- 인덱스 있음
CREATE INDEX idx_age ON users(age);
SELECT * FROM users WHERE age = 25;
-- 100만 건 → 약 20번 비교 (약 0.01초)
```

## 인덱스 사용 여부 확인

### EXPLAIN
```sql
EXPLAIN SELECT * FROM users WHERE name = '홍길동';
```

**결과 해석**:
- `type: ALL` → Full Table Scan ❌
- `type: index` → 인덱스 전체 스캔
- `type: range` → 인덱스 범위 스캔 ✅
- `type: ref` → 인덱스 동등 비교 ✅
- `type: const` → PK/Unique 조회 ⭐

## 인덱스가 사용되지 않는 경우

### 1. 인덱스 컬럼 가공
```sql
-- ❌ 인덱스 사용 안 됨
SELECT * FROM users WHERE YEAR(created_at) = 2025;
SELECT * FROM users WHERE age + 1 = 26;

-- ✅ 인덱스 사용
SELECT * FROM users WHERE created_at >= '2025-01-01' AND created_at < '2026-01-01';
SELECT * FROM users WHERE age = 25;
```

### 2. LIKE 앞에 와일드카드
```sql
-- ❌ 인덱스 사용 안 됨
SELECT * FROM users WHERE name LIKE '%길동';

-- ✅ 인덱스 사용
SELECT * FROM users WHERE name LIKE '홍%';
```

### 3. 부정 연산자
```sql
-- ❌ 인덱스 사용 안 됨
SELECT * FROM users WHERE age != 25;
SELECT * FROM users WHERE age NOT IN (25, 30);

-- ✅ 대안
SELECT * FROM users WHERE age < 25 OR age > 25;
```

### 4. OR 연산자
```sql
-- ❌ 인덱스 사용 안 됨 (name만 인덱스)
SELECT * FROM users WHERE name = '홍길동' OR age = 25;

-- ✅ UNION 사용
SELECT * FROM users WHERE name = '홍길동'
UNION
SELECT * FROM users WHERE age = 25;
```

### 5. 데이터 타입 불일치
```sql
-- ❌ 인덱스 사용 안 됨
SELECT * FROM users WHERE id = '100';  -- id는 INT

-- ✅ 타입 일치
SELECT * FROM users WHERE id = 100;
```


## 참고 자료

- [MySQL Index 문서](https://dev.mysql.com/doc/refman/8.0/en/optimization-indexes.html)
- [PostgreSQL Index](https://www.postgresql.org/docs/current/indexes.html)
- [Use The Index, Luke](https://use-the-index-luke.com/)