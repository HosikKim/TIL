# 데이터베이스 트리거 (Database Trigger)

## 개념

특정 이벤트 발생 시 **자동으로 실행**되는 프로시저

### 특징
- 이벤트 기반 자동 실행
- INSERT, UPDATE, DELETE 시 동작
- 명시적 호출 불가
- 데이터 무결성 유지

## 트리거 종류

### 1. 실행 시점
| 시점 | 설명 | 용도 |
|------|------|------|
| BEFORE | 이벤트 발생 **전** | 데이터 검증, 값 변경 |
| AFTER | 이벤트 발생 **후** | 로그 기록, 연관 테이블 갱신 |
| INSTEAD OF | 이벤트 **대신** 실행 | 뷰에 대한 DML |

### 2. 실행 레벨
- **행 레벨 (Row-level)**: 영향받는 각 행마다 실행
- **문장 레벨 (Statement-level)**: SQL문 당 1번 실행

## 기본 문법
```sql
-- MySQL
DELIMITER //
CREATE TRIGGER 트리거명
{BEFORE | AFTER} {INSERT | UPDATE | DELETE}
ON 테이블명
FOR EACH ROW
BEGIN
    -- 트리거 로직
END //
DELIMITER ;

-- 삭제
DROP TRIGGER 트리거명;
```

## 사용 예시

### 1. BEFORE INSERT - 데이터 검증
```sql
DELIMITER //
CREATE TRIGGER check_salary_before_insert
BEFORE INSERT ON employees
FOR EACH ROW
BEGIN
    IF NEW.salary < 0 THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = '급여는 0 이상이어야 합니다';
    END IF;
END //
DELIMITER ;
```

### 2. AFTER INSERT - 로그 기록
```sql
DELIMITER //
CREATE TRIGGER log_new_employee
AFTER INSERT ON employees
FOR EACH ROW
BEGIN
    INSERT INTO audit_log (action, table_name, record_id, changed_at)
    VALUES ('INSERT', 'employees', NEW.employee_id, NOW());
END //
DELIMITER ;
```

### 3. BEFORE UPDATE - 값 자동 설정
```sql
DELIMITER //
CREATE TRIGGER update_timestamp
BEFORE UPDATE ON employees
FOR EACH ROW
BEGIN
    SET NEW.updated_at = NOW();
END //
DELIMITER ;
```

### 4. AFTER DELETE - 연관 데이터 처리
```sql
DELIMITER //
CREATE TRIGGER archive_deleted_employee
AFTER DELETE ON employees
FOR EACH ROW
BEGIN
    INSERT INTO deleted_employees
    VALUES (OLD.employee_id, OLD.name, OLD.salary, NOW());
END //
DELIMITER ;
```

### 5. 재고 관리
```sql
DELIMITER //
CREATE TRIGGER update_stock
AFTER INSERT ON order_items
FOR EACH ROW
BEGIN
    UPDATE products
    SET stock = stock - NEW.quantity
    WHERE product_id = NEW.product_id;
END //
DELIMITER ;
```

## NEW vs OLD

| 구분 | NEW | OLD |
|------|-----|-----|
| INSERT | 삽입될 데이터 | 없음 |
| UPDATE | 변경 후 데이터 | 변경 전 데이터 |
| DELETE | 없음 | 삭제될 데이터 |
```sql
-- UPDATE 트리거 예시
DELIMITER //
CREATE TRIGGER check_salary_change
BEFORE UPDATE ON employees
FOR EACH ROW
BEGIN
    -- OLD: 기존 급여, NEW: 새 급여
    IF NEW.salary < OLD.salary THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = '급여는 감소할 수 없습니다';
    END IF;
END //
DELIMITER ;
```

## 주요 용도

1. **데이터 무결성**: 제약조건 이상의 복잡한 검증
2. **감사 추적**: 변경 이력 자동 기록
3. **자동 계산**: 집계 값 자동 갱신
4. **연관 테이블 동기화**: 관련 테이블 자동 업데이트
5. **업무 규칙 강제**: 비즈니스 로직 자동 적용

## 장점

| 장점 | 설명 |
|------|------|
| 자동화 | 데이터 변경 시 자동 실행 |
| 일관성 | 모든 데이터 변경에 동일한 규칙 적용 |
| 중앙 집중화 | DB 레벨에서 규칙 관리 |
| 보안 | 직접 테이블 조작 제한 가능 |

## 단점

| 단점 | 설명 |
|------|------|
| 복잡성 증가 | 암묵적 동작으로 디버깅 어려움 |
| 성능 저하 | 모든 DML에 추가 작업 |
| 순환 참조 위험 | 트리거가 트리거 호출 가능 |
| 이식성 낮음 | DBMS별 문법 상이 |

## 트리거 vs 스토어드 프로시저

| 구분 | 트리거 | 스토어드 프로시저 |
|------|--------|------------------|
| 실행 방식 | 자동 (이벤트) | 명시적 호출 (CALL) |
| 매개변수 | 불가 (NEW/OLD 사용) | 가능 (IN/OUT) |
| 트랜잭션 제어 | 불가 | 가능 (COMMIT/ROLLBACK) |
| 반환값 | 불가 | 가능 |
| 용도 | 무결성, 자동화 | 비즈니스 로직 |
| 가시성 | 낮음 (숨겨짐) | 높음 (명시적) |
```sql
-- 트리거: 자동 실행
INSERT INTO employees VALUES (...);  -- 트리거 자동 동작

-- 프로시저: 명시적 호출
CALL UpdateEmployee(100);  -- 명시적 호출 필요
```

## 주의사항

### 1. 순환 참조 방지
```sql
-- ❌ 무한 루프 위험
CREATE TRIGGER update_a
AFTER UPDATE ON table_a
FOR EACH ROW
    UPDATE table_b SET ...;  -- table_b 트리거 발동

CREATE TRIGGER update_b
AFTER UPDATE ON table_b
FOR EACH ROW
    UPDATE table_a SET ...;  -- 다시 table_a 트리거 발동
```

### 2. 트랜잭션 의존성
```sql
-- 트리거는 트리거를 발생시킨 트랜잭션에 포함됨
BEGIN;
INSERT INTO employees VALUES (...);  -- 트리거 실행
ROLLBACK;  -- 트리거 작업도 롤백됨
```

### 3. 성능 고려
```sql
-- ❌ 복잡한 로직은 성능 저하
CREATE TRIGGER slow_trigger
AFTER INSERT ON orders
FOR EACH ROW
BEGIN
    -- 복잡한 집계 쿼리
    -- 대량 데이터 처리
END;
```

## 트리거 조회
```sql
-- 트리거 목록
SHOW TRIGGERS;

-- 특정 테이블 트리거
SHOW TRIGGERS WHERE `Table` = 'employees';

-- 트리거 정의
SHOW CREATE TRIGGER 트리거명;
```

## 사용 가이드

**트리거 사용 시**:
- 데이터 무결성이 중요
- 자동 로그 기록 필요
- 연관 테이블 동기화

**트리거 지양 시**:
- 복잡한 비즈니스 로직
- 성능이 중요한 경우
- 명시적 제어 필요

## 참고 자료

- [MySQL Trigger 문서](https://dev.mysql.com/doc/refman/8.0/en/triggers.html)
- [Oracle Trigger](https://docs.oracle.com/en/database/oracle/oracle-database/19/lnpls/plsql-triggers.html)