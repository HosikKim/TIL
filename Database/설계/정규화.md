# 정규화 (Normalization)

## 개념

데이터 중복을 최소화하고 무결성을 보장하기 위해 테이블을 **구조화**하는 과정

### 목적
- 데이터 중복 제거
- 삽입/수정/삭제 이상 방지
- 저장 공간 효율화
- 데이터 일관성 유지

## 정규화 단계

### 제1정규형 (1NF)

**조건**: 모든 속성이 **원자값(Atomic Value)**을 가져야 함

**위반 예시**:
```
학생 (학번, 이름, 수강과목)
-----------------------------
1, 홍길동, "수학, 영어, 과학"  ❌ 반복 그룹
```

**정규화 후**:
```
학생 (학번, 이름)
1, 홍길동

수강 (학번, 과목)
1, 수학
1, 영어
1, 과학
```

**규칙**:
- 각 컬럼은 하나의 값만 포함
- 반복 그룹 제거
- 다중 값 속성 분리

### 제2정규형 (2NF)

**조건**: 1NF + **부분 함수 종속 제거**

**부분 함수 종속**: 기본키 일부에만 종속되는 속성

**위반 예시**:
```
수강 (학번, 과목코드, 학생이름, 과목명, 교수명)
기본키: (학번, 과목코드)

학생이름 → 학번에만 종속 ❌
과목명 → 과목코드에만 종속 ❌
교수명 → 과목코드에만 종속 ❌
```

**정규화 후**:
```
학생 (학번, 학생이름)
과목 (과목코드, 과목명, 교수명)
수강 (학번, 과목코드)
```

**규칙**:
- 복합키의 일부에만 종속된 속성 분리
- 완전 함수 종속만 유지

### 제3정규형 (3NF)

**조건**: 2NF + **이행 함수 종속 제거**

**이행 함수 종속**: A → B, B → C일 때 A → C

**위반 예시**:
```
학생 (학번, 이름, 학과코드, 학과명)

학번 → 학과코드 → 학과명 ❌ (이행 종속)
```

**정규화 후**:
```
학생 (학번, 이름, 학과코드)
학과 (학과코드, 학과명)
```

**규칙**:
- 기본키가 아닌 속성 간 종속 제거
- 직접 종속만 유지

### BCNF (Boyce-Codd Normal Form)

**조건**: 3NF + **모든 결정자가 후보키**

**위반 예시**:
```
수강 (학번, 과목, 교수)
후보키: (학번, 과목), (학번, 교수)

교수 → 과목 (교수가 결정자지만 후보키 아님) ❌
```

**정규화 후**:
```
교수과목 (교수, 과목)
수강 (학번, 교수)
```

**규칙**:
- 결정자는 반드시 후보키
- 일반 속성이 결정자 불가

## 정규화 단계 비교

| 정규형 | 조건 | 제거 대상 |
|--------|------|----------|
| 1NF | 원자값 | 반복 그룹, 다중 값 |
| 2NF | 1NF + 완전 함수 종속 | 부분 함수 종속 |
| 3NF | 2NF + 직접 종속 | 이행 함수 종속 |
| BCNF | 3NF + 결정자=후보키 | 후보키 아닌 결정자 |

## 함수 종속 (Functional Dependency)

### 표기법
```
A → B  (A가 B를 결정)
학번 → 이름  (학번이 결정되면 이름도 결정됨)
```

### 종류

**완전 함수 종속**:
```
(학번, 과목) → 성적  ✅
학번만으로는 성적 결정 불가
과목만으로는 성적 결정 불가
```

**부분 함수 종속**:
```
(학번, 과목) → 학생이름  ❌
학번만으로 학생이름 결정 가능
```

**이행 함수 종속**:
```
학번 → 학과코드 → 학과명  ❌
학번 → 학과명 (간접 종속)
```

## 정규화 실습 예제

### 비정규형 테이블
```
주문 (주문번호, 고객명, 고객전화, 상품1, 수량1, 가격1, 상품2, 수량2, 가격2)
```

### 1NF 적용
```
주문 (주문번호, 고객명, 고객전화, 상품, 수량, 가격)

1, 홍길동, 010-1111, 노트북, 1, 1000000
1, 홍길동, 010-1111, 마우스, 2, 20000
```

### 2NF 적용
```
주문 (주문번호, 고객명, 고객전화)
1, 홍길동, 010-1111

주문상세 (주문번호, 상품, 수량, 가격)
1, 노트북, 1, 1000000
1, 마우스, 2, 20000
```

### 3NF 적용
```
고객 (고객ID, 고객명, 전화)
1, 홍길동, 010-1111

주문 (주문번호, 고객ID, 주문일자)
1, 1, 2025-01-01

상품 (상품ID, 상품명, 단가)
1, 노트북, 1000000
2, 마우스, 10000

주문상세 (주문번호, 상품ID, 수량)
1, 1, 1
1, 2, 2
```

## 이상 현상 (Anomaly)

### 삽입 이상 (Insertion Anomaly)
```
학생 (학번, 이름, 학과코드, 학과명)

새 학과 개설 시 학생 없이 학과만 등록 불가 ❌
```

### 수정 이상 (Update Anomaly)
```
학생 (학번, 이름, 학과코드, 학과명)

학과명 변경 시 모든 학생 레코드 수정 필요 ❌
수정 누락 시 데이터 불일치
```

### 삭제 이상 (Deletion Anomaly)
```
학생 (학번, 이름, 학과코드, 학과명)

마지막 학생 삭제 시 학과 정보도 삭제됨 ❌
```

## 역정규화 (Denormalization)

**정의**: 성능 향상을 위해 **의도적으로** 중복을 허용

**시기**:
- 조인 연산이 과도하게 발생
- 집계 쿼리가 빈번
- 읽기 성능이 중요

**방법**:
```sql
-- 정규화
SELECT o.order_id, c.name, c.phone
FROM orders o
JOIN customers c ON o.customer_id = c.customer_id;

-- 역정규화 (고객명, 전화 중복 저장)
SELECT order_id, customer_name, customer_phone
FROM orders;
```

**장점**: 조회 성능 향상
**단점**: 데이터 중복, 수정 이상 가능성

## 정규화 vs 역정규화

| 구분 | 정규화 | 역정규화 |
|------|--------|---------|
| 중복 | 최소화 | 허용 |
| 무결성 | 높음 | 낮음 |
| 저장 공간 | 적음 | 많음 |
| 조회 성능 | 느림 (조인) | 빠름 |
| 수정 성능 | 빠름 | 느림 |
| 적합 상황 | OLTP | OLAP, 읽기 위주 |

## 정규화 수준 결정

### 완전 정규화 (3NF/BCNF)
- 트랜잭션 중심 시스템 (OLTP)
- 데이터 무결성 중요
- 쓰기 작업 빈번

### 부분 정규화 (2NF)
- 성능과 무결성 균형
- 일반적인 웹 서비스

### 역정규화
- 분석/보고서 시스템 (OLAP)
- 읽기 성능 최우선
- 배치로 데이터 동기화

## 실무 가이드

**정규화 우선 적용**:
- 설계 단계에서 3NF까지 정규화
- 성능 테스트 후 필요시 역정규화

**역정규화 고려**:
- 빈번한 조인으로 성능 저하
- 복잡한 집계 쿼리
- 읽기 : 쓰기 비율이 100:1 이상

**대안**:
- 인덱스 최적화
- 뷰(View) 활용
- 캐싱
- 읽기 전용 복제본

## 참고 자료

- [정규화 이론](https://en.wikipedia.org/wiki/Database_normalization)
- [함수 종속성](https://www.geeksforgeeks.org/functional-dependency-and-attribute-closure/)