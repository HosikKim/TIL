# 트리 (Tree)

## 개념
계층적 구조를 표현하는 비선형 자료구조로, 노드들이 부모-자식 관계로 연결됨

## 목적
* 계층적 데이터 표현 (파일 시스템, 조직도)
* 효율적인 탐색 및 정렬 (이진 탐색 트리)
* 범위 쿼리 처리 (세그먼트 트리)
* 최소 공통 조상 찾기 (LCA)

## 트리의 특징

* **사이클이 없는 연결 그래프**
* N개의 노드 → N-1개의 에지
* 루트(Root)에서 시작해 자식 노드들로 뻗어나가는 구조
* 임의의 두 노드 간에는 **유일한 경로**만 존재

## 트리의 구성요소

| 용어 | 설명 |
|------|------|
| 노드(Node) | 트리의 기본 단위 (데이터 저장) |
| 루트(Root) | 최상위 노드 (부모가 없음) |
| 부모(Parent) | 상위 연결된 노드 |
| 자식(Child) | 하위 연결된 노드 |
| 리프(Leaf) | 자식이 없는 노드 (단말 노드) |
| 간선(Edge) | 노드를 연결하는 선 |
| 깊이(Depth) | 루트에서 해당 노드까지의 거리 |
| 높이(Height) | 리프 노드까지의 최대 거리 |
| 레벨(Level) | 깊이 + 1 (루트의 레벨은 1) |

## 코딩 테스트에서 트리 표현

### 1. 그래프로 푸는 Tree

**인접 리스트 + DFS/BFS**

```java
// 인접 리스트로 트리 표현
ArrayList<Integer>[] tree = new ArrayList[n + 1];
for (int i = 1; i <= n; i++) {
    tree[i] = new ArrayList<>();
}

// 양방향 연결 (무방향 트리)
tree[1].add(2);
tree[2].add(1);

// DFS로 트리 탐색
void dfs(int node, int parent) {
    for (int child : tree[node]) {
        if (child != parent) {  // 부모로 역행 방지
            dfs(child, node);
        }
    }
}
```

**활용**: 일반적인 트리 탐색, 트리 DP, 서브트리 문제

### 2. 배열로 푸는 Tree

**1차원 배열로 트리 표현** (이진 트리, 세그먼트 트리, LCA)

```java
// 인덱스: 0  1  2  3  4  5  6  7
// 값:    -  A  B  C  D  E  F  G

char[] tree = new char[8];
tree[1] = 'A';  // 루트
tree[2] = 'B';  // A의 왼쪽 자식
tree[3] = 'C';  // A의 오른쪽 자식
```

**인덱스 관계**
```java
int parent = index / 2;          // 부모 노드
int leftChild = index * 2;       // 왼쪽 자식
int rightChild = index * 2 + 1;  // 오른쪽 자식
```

**활용**: 이진 트리, 힙, 세그먼트 트리, LCA (희소 배열)

## 트리 종류

| 트리 종류 | 설명 |
|----------|------|
| 이진 트리 | 자식이 최대 2개 |
| 이진 탐색 트리 | 왼쪽 < 부모 < 오른쪽 |
| 완전 이진 트리 | 마지막 레벨 제외 꽉 참 |
| 포화 이진 트리 | 모든 레벨이 꽉 참 |
| 세그먼트 트리 | 구간 쿼리 처리 (추후 상세 정리) |

## 트리 순회 방식

```java
void preorder(int node) {    // 전위: 루트 → 왼 → 오
    visit(node);
    preorder(left);
    preorder(right);
}

void inorder(int node) {     // 중위: 왼 → 루트 → 오
    inorder(left);
    visit(node);
    inorder(right);
}

void postorder(int node) {   // 후위: 왼 → 오 → 루트
    postorder(left);
    postorder(right);
    visit(node);
}
```

## 시간 복잡도

| 연산 | 일반 트리 | 이진 탐색 트리 (균형) |
|------|----------|---------------------|
| 탐색 | O(N) | O(log N) |
| 삽입 | O(1) | O(log N) |
| 삭제 | O(1) | O(log N) |

## 장점 및 단점

### 장점
* 계층 구조 표현에 최적
* 이진 탐색 트리는 빠른 탐색 가능
* 재귀적 구조로 구현 용이

### 단점
* 선형 구조보다 복잡
* 불균형 트리는 성능 저하
* 구현에 따라 메모리 오버헤드

## 참고 자료
* 관련 알고리즘: DFS, BFS, 트리 DP, LCA
* 추천 문제: BOJ 1991 (트리 순회)
```java
import java.io.*;
import java.util.*;

class Node {
    char value;
    Node left;
    Node right;

    Node(char value) {
        this.value = value;
    }
}

public class Main {
    static Node[] nodes = new Node[26];

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());

        for (int i = 0; i < n; i++) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            char parent = st.nextToken().charAt(0);
            char left = st.nextToken().charAt(0);
            char right = st.nextToken().charAt(0);


            // Java에서 char 데이터 타입은 내부적으로 ASCII 코드 사용
            int parentIdx = parent - 'A'; // A->0, B->1...
            if (nodes[parentIdx] == null) {
                nodes[parentIdx] = new Node(parent);
            }
            if (left != '.') {
                int leftIdx = left - 'A';
                nodes[leftIdx] = new Node(left);
                nodes[parentIdx].left = nodes[leftIdx];
            }
            if (right != '.') {
                int rightIdx = right - 'A';
                nodes[rightIdx] = new Node(right);
                nodes[parentIdx].right = nodes[rightIdx];
            }
        }

        preorder(nodes[0]);
        System.out.println();
        inorder(nodes[0]);
        System.out.println();
        postorder(nodes[0]);
    }

    //전위 순회
    static void preorder(Node node) {
        if (node == null)
            return;
        System.out.print(node.value);
        preorder(node.left);
        preorder(node.right);
    }


    //중위 순회
    static void inorder(Node node) {
        if (node == null)
            return;
        inorder(node.left);
        System.out.print(node.value);
        inorder(node.right);
    }


    //후위 순회
    static void postorder(Node node) {
        if (node == null)
            return;
        postorder(node.left);
        postorder(node.right);
        System.out.print(node.value);
    }
}
```