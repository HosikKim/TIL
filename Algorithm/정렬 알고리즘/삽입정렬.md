# 삽입 정렬 (Insertion Sort)

## 개념
이미 정렬된 데이터 범위에 정렬되지 않은 데이터를 적절한 위치에 삽입시켜 정렬하는 방식

## 목적
* 단순하고 직관적인 정렬 방법 구현
* 거의 정렬된 데이터를 효율적으로 정렬
* 작은 데이터셋에서 빠른 정렬 제공

## 핵심 아이디어
**정렬된 영역에서 적절한 위치를 찾아 삽입 → 정렬된 영역을 점진적으로 확장**

## 정렬 과정

### 동작 단계
1. **두 번째 원소부터 시작** (첫 번째는 이미 정렬된 것으로 간주)
2. **현재 원소를 선택**하여 임시 저장
3. **정렬된 영역을 역순으로 탐색**하며 삽입 위치 찾기
4. **삽입 위치보다 큰 원소들을 오른쪽으로 이동**
5. **찾은 위치에 원소 삽입**
6. 모든 원소가 정렬될 때까지 반복

### 동작 과정 예시
**초기 배열**: `[5, 3, 8, 1, 2]`

```
초기 상태: [5] | 3, 8, 1, 2
           정렬됨 | 미정렬

1회전: 3을 정렬된 영역에 삽입
현재 값: 3
[5] | 3, 8, 1, 2
 ↓
5 > 3 → 5를 오른쪽으로
[_, 5] | 8, 1, 2
3을 첫 위치에 삽입
[3, 5] | 8, 1, 2

2회전: 8을 정렬된 영역에 삽입
현재 값: 8
[3, 5] | 8, 1, 2
      ↓
8 > 5 → 그대로 유지
[3, 5, 8] | 1, 2

3회전: 1을 정렬된 영역에 삽입
현재 값: 1
[3, 5, 8] | 1, 2
       ↓
8 > 1 → 8을 오른쪽으로
[3, 5, _, 8] | 2
    ↓
5 > 1 → 5를 오른쪽으로
[3, _, 5, 8] | 2
 ↓
3 > 1 → 3을 오른쪽으로
[_, 3, 5, 8] | 2
1을 첫 위치에 삽입
[1, 3, 5, 8] | 2

4회전: 2를 정렬된 영역에 삽입
현재 값: 2
[1, 3, 5, 8] | 2
          ↓
8 > 2 → 8을 오른쪽으로
[1, 3, 5, _, 8]
       ↓
5 > 2 → 5를 오른쪽으로
[1, 3, _, 5, 8]
    ↓
3 > 2 → 3을 오른쪽으로
[1, _, 3, 5, 8]
 ↓
1 < 2 → 2를 이 위치에 삽입
[1, 2, 3, 5, 8]

최종 결과: [1, 2, 3, 5, 8]
```

## 구현 코드

```java
public static void insertionSort(int[] arr) {
    int n = arr.length;
    
    // 두 번째 원소부터 시작
    for (int i = 1; i < n; i++) {
        int key = arr[i];  // 현재 삽입할 값
        int j = i - 1;     // 정렬된 영역의 마지막 인덱스
        
        // 정렬된 영역을 역순으로 탐색하며 삽입 위치 찾기
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];  // 오른쪽으로 이동
            j--;
        }
        
        // 찾은 위치에 삽입
        arr[j + 1] = key;
    }
}
```

### 내림차순 정렬
```java
// 부등호만 변경
while (j >= 0 && arr[j] < key) {
    arr[j + 1] = arr[j];
    j--;
}
```

## 시간복잡도 및 공간복잡도

| 경우 | 시간복잡도 | 비고 |
|------|-----------|------|
| 최악의 경우 | O(n²) | 역순 정렬된 경우 |
| 평균 | O(n²) | 랜덤 데이터 |
| 최선의 경우 | O(n) | 이미 정렬된 경우 |
| 공간복잡도 | O(1) | 제자리 정렬 (in-place) |

**특징**: 시간복잡도는 **O(n²)로 느린 편**이지만, **이미 정렬된 경우 O(n)**으로 매우 빠름

## 이미 정렬된 경우의 효율성

```java
배열: [1, 2, 3, 4, 5] (이미 정렬됨)

1회전: 2를 확인 → 1 < 2 → 이동 없음
2회전: 3을 확인 → 2 < 3 → 이동 없음
3회전: 4를 확인 → 3 < 4 → 이동 없음
4회전: 5를 확인 → 4 < 5 → 이동 없음

→ 각 원소당 1번만 비교 → O(n)
```

## 장점
* **구현이 매우 쉬움**: 이해하기 쉽고 코드가 간단
* **안정 정렬**: 같은 값의 순서가 유지됨
* **제자리 정렬**: 추가 메모리가 거의 필요 없음 (O(1))
* **거의 정렬된 경우 매우 효율적**: O(n)에 가까운 성능
* **온라인 정렬 가능**: 데이터를 받으면서 바로 정렬 가능

## 단점
* **평균 시간복잡도 O(n²)**: 데이터가 많으면 느림
* **역순 정렬된 경우 최악**: 모든 원소를 이동해야 함
* **큰 데이터셋에는 부적합**: n이 클수록 비효율적

## 온라인 정렬 예시

```java
// 데이터를 받으면서 바로 정렬
int[] sortedArray = new int[100];
int size = 0;

// 새 데이터가 들어올 때마다 삽입
void addData(int newValue) {
    sortedArray[size] = newValue;
    // 적절한 위치에 삽입
    int i = size - 1;
    while (i >= 0 && sortedArray[i] > newValue) {
        sortedArray[i + 1] = sortedArray[i];
        i--;
    }
    sortedArray[i + 1] = newValue;
    size++;
}
```

## 사용 가이드

### 언제 사용하면 좋은가?
* **데이터 개수가 적을 때** (n < 50)
* **거의 정렬된 데이터**를 정렬할 때
* **온라인 정렬**이 필요할 때 (데이터를 받으면서 정렬)
* **안정 정렬**이 필요할 때
* **구현이 간단해야** 할 때

### 언제 사용하지 말아야 하는가?
* **데이터 개수가 많을 때** (n > 1000)
* **역순으로 정렬된 데이터**
* **랜덤하게 섞인 대용량 데이터**
* **성능이 중요한 코딩 테스트** (시간 초과 위험)

## 거의 정렬된 데이터의 예

```java
// 거의 정렬된 경우 (1개만 잘못된 위치)
[1, 2, 3, 4, 5, 0, 6, 7, 8, 9]
                ↑
// 0만 이동하면 됨 → 매우 빠름

// vs 역순 정렬된 경우
[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
// 모든 원소를 이동해야 함 → 매우 느림
```

## 주의사항
* **역순 정렬 시 최악**: O(n²)로 매우 느림
* **큰 데이터에는 부적합**: n이 클수록 비효율적
* **코딩 테스트 주의**: 데이터 크기 확인 필요


## 핵심 정리
* 삽입 정렬은 **정렬된 영역에 적절한 위치를 찾아 삽입**
* **시간복잡도 O(n²)로 느린 편**이지만 **구현이 쉬움**
* **거의 정렬된 경우 O(n)** 으로 매우 효율적
* **작은 데이터**나 **온라인 정렬**에 적합
* **안정 정렬**이라 같은 값의 순서 유지