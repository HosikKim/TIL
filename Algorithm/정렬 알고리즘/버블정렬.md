# 버블 정렬 (Bubble Sort)

## 개념
인접한 두 데이터를 비교하여 swap하는 방식으로 정렬하는 알고리즘

## 목적
* 단순하고 직관적인 정렬 방법 구현
* 정렬 알고리즘의 기본 원리 학습
* 작은 데이터셋에서 간단한 정렬이 필요할 때 사용

## 이름의 유래
원소가 이동하는 모습이 **거품(bubble)이 수면으로 올라오는 것**처럼 보여서 버블 정렬이라 명명됨

## 동작 원리

### 핵심 로직
1. 배열의 처음부터 끝까지 **인접한 두 원소를 비교**
2. 순서가 잘못되어 있으면 **swap**
3. 한 번의 루프가 끝나면 **가장 큰 값이 맨 뒤로** 이동
4. 정렬된 영역(뒤쪽)은 제외하고 나머지 영역에서 반복

### 동작 과정 예시
**초기 배열**: `[10, 18, 12, 15, 17]`

#### 1회전 (4번 비교)
```
[10, 18, 12, 15, 17]  → 10 < 18 (변화 없음)
[10, 18, 12, 15, 17]  → 18 > 12 (swap) → [10, 12, 18, 15, 17]
[10, 12, 18, 15, 17]  → 18 > 15 (swap) → [10, 12, 15, 18, 17]
[10, 12, 15, 18, 17]  → 18 > 17 (swap) → [10, 12, 15, 17, 18]
```
→ **18이 제자리로** (정렬된 영역: [18])

#### 2회전 (3번 비교)
```
[10, 12, 15, 17, |18]  → 10 < 12 (변화 없음)
[10, 12, 15, 17, |18]  → 12 < 15 (변화 없음)
[10, 12, 15, 17, |18]  → 15 < 17 (변화 없음)
```
→ **swap이 한 번도 발생하지 않음** → 정렬 완료, 종료 가능

## 최적화: 조기 종료 조건

```java
boolean swapped = false;

for (int i = 0; i < n - 1; i++) {
    swapped = false;
    
    for (int j = 0; j < n - 1 - i; j++) {
        if (arr[j] > arr[j + 1]) {
            swap(arr, j, j + 1);
            swapped = true;
        }
    }
    
    // 한 번의 루프에서 swap이 없으면 정렬 완료
    if (!swapped) break;
}
```

**조기 종료의 의미**:
- 특정 루프에서 **전체 영역에서 swap이 한 번도 발생하지 않으면** 모든 데이터가 정렬된 상태
- 더 이상 비교할 필요 없이 프로세스 종료 가능

## 구현 코드

```java
public static void bubbleSort(int[] arr) {
    int n = arr.length;
    
    for (int i = 0; i < n - 1; i++) {
        boolean swapped = false;
        
        // 정렬된 영역(n-1-i) 제외하고 비교
        for (int j = 0; j < n - 1 - i; j++) {
            if (arr[j] > arr[j + 1]) {
                // swap
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
                swapped = true;
            }
        }
        
        // 최적화: swap 없으면 정렬 완료
        if (!swapped) break;
    }
}
```

## 시간복잡도 및 공간복잡도

| 경우 | 시간복잡도 | 비고 |
|------|-----------|------|
| 최악의 경우 | O(n²) | 역순 정렬 상태 |
| 평균 | O(n²) | 랜덤 데이터 |
| 최선의 경우 | O(n) | 이미 정렬된 상태 (조기 종료) |
| 공간복잡도 | O(1) | 제자리 정렬 (in-place) |

## 장점
* **구현이 매우 간단**하고 이해하기 쉬움
* **제자리 정렬**(in-place): 추가 메모리 불필요
* **안정 정렬**(stable): 같은 값의 순서가 유지됨

## 단점
* **시간복잡도 O(n²)**: 다른 정렬 알고리즘보다 느림
* 데이터가 많을수록 비효율적
* 실무에서는 거의 사용되지 않음

## 사용 가이드

### 언제 사용하면 좋은가?
* 데이터 개수가 **매우 적을 때** (n < 20)
* **교육 목적**으로 정렬 원리를 학습할 때
* 이미 거의 정렬되어 있고 **조기 종료 최적화**를 활용할 수 있을 때

### 언제 사용하지 말아야 하는가?
* 데이터 개수가 많을 때 (n > 100)
* 성능이 중요한 실무 프로젝트
* 빠른 정렬이 필요한 경우 → 퀵 정렬, 병합 정렬 사용

## 주의사항
* 코딩 테스트에서는 시간 초과 위험이 높음
* 최적화(조기 종료)를 반드시 적용할 것
* 실무에서는 `Arrays.sort()` (퀵 정렬 기반) 사용 권장

## 참고 자료
* 추천 문제: BOJ 2750 (수 정렬하기), BOJ 1377 (버블 소트)