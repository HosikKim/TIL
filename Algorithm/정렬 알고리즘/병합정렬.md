# 병합 정렬 (Merge Sort / 합병정렬)

## 개념
분할정복 방식을 사용해 데이터를 분할하고, 분할한 집합을 정렬하며 합치는 알고리즘

## 목적
* 안정적인 O(n log n) 정렬 구현
* 분할정복 기법 학습
* 큰 데이터를 효율적으로 정렬

## 핵심 아이디어
**데이터를 최소 단위까지 분할 → 정렬하며 병합 → 완전히 정렬된 배열 완성**

## 정렬 과정

### 분할 단계
**초기 배열**: `[42, 32, 24, 60, 15, 5, 90, 45]`

```
레벨 0 (원본):
[42, 32, 24, 60, 15, 5, 90, 45]

레벨 1 (2개 그룹으로 분할):
[42, 32, 24, 60] | [15, 5, 90, 45]

레벨 2 (4개 그룹으로 분할):
[42, 32] | [24, 60] | [15, 5] | [90, 45]

레벨 3 (8개 그룹으로 분할 - 최소 단위):
[42] | [32] | [24] | [60] | [15] | [5] | [90] | [45]
set1  set2  set3  set4  set5  set6  set7  set8
```

### 병합 단계 (정렬하며 합치기)
```
레벨 3 → 레벨 2:
[32, 42] | [24, 60] | [5, 15] | [45, 90]

레벨 2 → 레벨 1:
[24, 32, 42, 60] | [5, 15, 45, 90]

레벨 1 → 레벨 0 (최종):
[5, 15, 24, 32, 42, 45, 60, 90]
```

## 투 포인터를 이용한 병합 과정 ⭐

**이 과정을 숙지하는 것이 중요!**

### 예시: 두 그룹 병합
```
그룹 1: [24, 32, 42, 60]
그룹 2: [5, 15, 45, 90]
결과: []

1단계: 24 vs 5 → 5가 작음
L: [24, 32, 42, 60]
    ↑
R: [5, 15, 45, 90]
    ↑
결과: [5]
R 포인터 이동 →

2단계: 24 vs 15 → 15가 작음
L: [24, 32, 42, 60]
    ↑
R: [5, 15, 45, 90]
        ↑
결과: [5, 15]
R 포인터 이동 →

3단계: 24 vs 45 → 24가 작음
L: [24, 32, 42, 60]
    ↑
R: [5, 15, 45, 90]
            ↑
결과: [5, 15, 24]
L 포인터 이동 →

4단계: 32 vs 45 → 32가 작음
L: [24, 32, 42, 60]
        ↑
R: [5, 15, 45, 90]
            ↑
결과: [5, 15, 24, 32]
L 포인터 이동 →

5단계: 42 vs 45 → 42가 작음
L: [24, 32, 42, 60]
            ↑
R: [5, 15, 45, 90]
            ↑
결과: [5, 15, 24, 32, 42]
L 포인터 이동 →

6단계: 60 vs 45 → 45가 작음
L: [24, 32, 42, 60]
                ↑
R: [5, 15, 45, 90]
            ↑
결과: [5, 15, 24, 32, 42, 45]
R 포인터 이동 →

7단계: 60 vs 90 → 60이 작음
L: [24, 32, 42, 60]
                ↑
R: [5, 15, 45, 90]
                ↑
결과: [5, 15, 24, 32, 42, 45, 60]
L 포인터 이동 →

8단계: L 그룹 끝 → R 나머지 추가
결과: [5, 15, 24, 32, 42, 45, 60, 90]
```

## 구현 코드

```java
public static void mergeSort(int[] arr, int left, int right) {
    if (left < right) {
        int mid = (left + right) / 2;
        
        // 분할
        mergeSort(arr, left, mid);      // 왼쪽 절반 정렬
        mergeSort(arr, mid + 1, right); // 오른쪽 절반 정렬
        
        // 병합
        merge(arr, left, mid, right);
    }
}

private static void merge(int[] arr, int left, int mid, int right) {
    int[] temp = new int[right - left + 1];
    int i = left;      // 왼쪽 그룹 포인터
    int j = mid + 1;   // 오른쪽 그룹 포인터
    int k = 0;         // 결과 배열 인덱스
    
    // 두 그룹을 비교하며 병합 (투 포인터)
    while (i <= mid && j <= right) {
        if (arr[i] <= arr[j]) {
            temp[k++] = arr[i++];
        } else {
            temp[k++] = arr[j++];
        }
    }
    
    // 왼쪽 그룹 남은 원소 추가
    while (i <= mid) {
        temp[k++] = arr[i++];
    }
    
    // 오른쪽 그룹 남은 원소 추가
    while (j <= right) {
        temp[k++] = arr[j++];
    }
    
    // 결과를 원본 배열에 복사
    for (int idx = 0; idx < temp.length; idx++) {
        arr[left + idx] = temp[idx];
    }
}
```

## 시간복잡도 및 공간복잡도

| 경우 | 시간복잡도 | 비고 |
|------|-----------|------|
| 최악의 경우 | O(n log n) | 항상 동일 |
| 평균 | O(n log n) | 항상 동일 |
| 최선의 경우 | O(n log n) | 항상 동일 |
| 공간복잡도 | O(n) | 임시 배열 필요 |

**특징**: 모든 경우에 **안정적으로 O(n log n)** 보장

## 시간복잡도 분석

```
분할 단계: O(log n) 레벨
- 8개 → 4개 → 2개 → 1개 (log₂8 = 3레벨)

각 레벨에서 병합: O(n)
- 모든 원소를 한 번씩 처리

총 시간복잡도: O(n) × O(log n) = O(n log n)
```

## 장점
* **안정적인 O(n log n)**: 항상 같은 성능 보장
* **안정 정렬**: 같은 값의 순서가 유지됨
* **예측 가능한 성능**: 최악의 경우에도 O(n log n)
* **큰 데이터에 적합**: 데이터가 많을수록 유리

## 단점
* **추가 메모리 필요**: O(n) 공간 필요 (임시 배열)
* **작은 데이터에는 오버헤드**: 분할/병합 과정의 오버헤드
* **제자리 정렬 아님**: 추가 메모리 사용

## 병합 정렬 응용: 역전 개수 세기 ⭐

**병합 과정을 제대로 이해하면 이런 응용 문제를 풀 수 있음**

### 문제 예시
두 그룹의 차량이 경기에서 몇 번의 역전이 일어났는지 계산

```
그룹 1: [24, 32, 42, 60]
그룹 2: [5, 15, 45, 90]

역전이란? 그룹2의 차량이 그룹1의 차량을 추월하는 것
```

### 역전 개수 계산
```
1. 5가 선택됨 → 그룹1의 [24, 32, 42, 60] 모두 추월
   역전 횟수: +4 (총 4번)

2. 15가 선택됨 → 그룹1의 [24, 32, 42, 60] 모두 추월
   역전 횟수: +4 (총 8번)

3. 24 선택 → 역전 없음 (총 8번)

4. 32 선택 → 역전 없음 (총 8번)

5. 42 선택 → 역전 없음 (총 8번)

6. 45 선택됨 → 그룹1의 [60] 추월
   역전 횟수: +1 (총 9번)

7. 60 선택 → 역전 없음 (총 9번)

8. 90 선택 → 역전 없음 (총 9번)

최종 역전 횟수: 9번
```

### 역전 개수 세기 구현
```java
private static int mergeAndCount(int[] arr, int left, int mid, int right) {
    int[] temp = new int[right - left + 1];
    int i = left;
    int j = mid + 1;
    int k = 0;
    int inversionCount = 0;  // 역전 개수
    
    while (i <= mid && j <= right) {
        if (arr[i] <= arr[j]) {
            temp[k++] = arr[i++];
        } else {
            // 오른쪽 그룹의 원소가 선택됨 → 역전 발생
            temp[k++] = arr[j++];
            inversionCount += (mid - i + 1);  // 왼쪽 그룹의 남은 원소 개수만큼 역전
        }
    }
    
    // 나머지 처리
    while (i <= mid) temp[k++] = arr[i++];
    while (j <= right) temp[k++] = arr[j++];
    
    // 원본 배열에 복사
    for (int idx = 0; idx < temp.length; idx++) {
        arr[left + idx] = temp[idx];
    }
    
    return inversionCount;
}
```

### 응용 문제 핵심
**병합 과정에서 오른쪽 그룹의 원소가 선택될 때, 왼쪽 그룹의 남은 원소 개수가 역전 횟수**

이런 아이디어는 **병합 과정을 완전히 이해해야** 떠올릴 수 있음

## 사용 가이드

### 언제 사용하면 좋은가?
* **안정적인 성능**이 필요할 때
* **안정 정렬**이 필요할 때 (같은 값의 순서 유지)
* **큰 데이터**를 정렬할 때
* **최악의 경우를 대비**해야 할 때
* **역전 개수** 같은 응용 문제

### 언제 사용하지 말아야 하는가?
* **메모리가 제한적**일 때 (O(n) 추가 메모리)
* **작은 데이터**셋 (오버헤드가 클 수 있음)
* **제자리 정렬**이 필요할 때

## 주의사항
* **추가 메모리 필요**: O(n) 공간 필요
* **재귀 깊이**: log n 만큼의 재귀 호출 스택
* **병합 과정 이해 필수**: 응용 문제를 풀기 위해 필수

## 분할정복 원리

```
분할정복 = Divide and Conquer

1. Divide (분할): 문제를 작은 문제로 나눔
   → 배열을 절반으로 분할

2. Conquer (정복): 작은 문제를 해결
   → 각각의 부분 배열을 정렬

3. Combine (결합): 해결한 결과를 합침
   → 정렬된 부분 배열을 병합
```

## 핵심 정리
* 병합 정렬은 **분할정복 방식으로 분할하고 병합하며 정렬**
* **시간복잡도 O(n log n)** 보장
* **투 포인터를 이용한 병합 과정**을 반드시 숙지
* **병합 과정 이해**가 응용 문제 해결의 핵심
* **역전 개수 세기** 같은 응용이 가능
* **안정 정렬**이며 큰 데이터에 적합