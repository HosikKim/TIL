# 퀵 정렬 (Quick Sort)

## 개념
기준값(pivot)을 선정해 해당 값보다 작은 데이터와 큰 데이터로 분류하는 것을 반복하는 정렬 알고리즘

## 목적
* 효율적인 정렬 알고리즘 구현
* 분할 정복(Divide and Conquer) 기법 학습
* 평균적으로 빠른 정렬 속도 제공

## 핵심 아이디어
**pivot을 기준으로 작은 값은 왼쪽, 큰 값은 오른쪽으로 분할 → 재귀적으로 반복**

## 정렬 과정

### 동작 단계
1. **pivot(기준값) 선정** (예: 가장 오른쪽 데이터)
2. **start가 pivot보다 작으면** → start를 오른쪽으로 1칸 이동
3. **end가 pivot보다 크면** → end를 왼쪽으로 1칸 이동
4. **start가 pivot보다 크고 end가 pivot보다 작으면** → start와 end를 swap 후 start는 오른쪽으로 1칸 end는 왼쪽으로 1칸 이동
5. **start와 end가 만날 때까지** 2~4 반복
6. **만난 지점에 pivot 삽입** 
   - 만난 지점의 데이터가 pivot보다 크면 → 오른쪽에 삽입
   - 만난 지점의 데이터가 pivot보다 작으면 → 왼쪽에 삽입
7. **분리된 집합에서 다시 pivot 선정** → 분리 집합이 1개 이하가 될 때까지 반복

### 동작 과정 예시
**초기 배열**: `[42, 32, 24, 60, 15, 90, 45]`

#### 1회전: pivot = 45 (가장 오른쪽)
```
[42, 32, 24, 60, 15, 90, 45]
 S                   E   P

1) 42 < 45 → start 이동
[42, 32, 24, 60, 15, 90, 45]
     S               E   P

2) 32 < 45 → start 이동
[42, 32, 24, 60, 15, 90, 45]
         S           E   P

3) 24 < 45 → start 이동
[42, 32, 24, 60, 15, 90, 45]
             S       E   P

4) 60 > 45 && 90 > 45 → end 이동
[42, 32, 24, 60, 15, 90, 45]
             S   E       P

5) 60 > 45 && 15 < 45 → swap 후 이동
[42, 32, 24, 15, 60, 90, 45]
                 S   E   P

6) start와 end 만남 → 60 > 45이므로 왼쪽에 pivot 삽입
[42, 32, 24, 15, 45, 60, 90]
                 P

→ [42, 32, 24, 15] | 45 | [60, 90]
```

#### 2회전: 왼쪽 [42, 32, 24, 15] 정렬
```
pivot = 15
[15, 32, 24, 42] | 45 | [60, 90]
```

#### 3회전: 오른쪽 [60, 90] 정렬
```
pivot = 90
[15, 32, 24, 42] | 45 | [60, 90]
```

#### 최종 결과
```
[15, 24, 32, 42, 45, 60, 90]
```

## 구현 코드

```java
public static void quickSort(int[] arr, int left, int right) {
    if (left >= right) {
        return;  // 종료 조건
    }
    
    int pivot = partition(arr, left, right);
    quickSort(arr, left, pivot - 1);   // 왼쪽 부분 정렬
    quickSort(arr, pivot + 1, right);  // 오른쪽 부분 정렬
}

private static int partition(int[] arr, int left, int right) {
    int pivot = arr[right];  // 가장 오른쪽을 pivot으로
    int start = left;
    int end = right - 1;
    
    while (start <= end) {
        // start가 pivot보다 작으면 이동
        while (start <= end && arr[start] < pivot) {
            start++;
        }
        
        // end가 pivot보다 크면 이동
        while (start <= end && arr[end] > pivot) {
            end--;
        }
        
        // start와 end가 아직 안 만났으면 swap
        if (start <= end) {
            swap(arr, start, end);
            start++;
            end--;
        }
    }
    
    // pivot을 제자리에 삽입
    swap(arr, start, right);
    return start;
}

private static void swap(int[] arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
```

## 시간복잡도 및 공간복잡도

| 경우 | 시간복잡도 | 비고 |
|------|-----------|------|
| 평균 | O(n log n) | 비교적 준수한 성능 |
| 최선의 경우 | O(n log n) | pivot이 중앙값일 때 |
| 최악의 경우 | O(n²) | 이미 정렬된 경우 (pivot이 최소/최대값) |
| 공간복잡도 | O(log n) | 재귀 호출 스택 |

**특징**: 평균적으로 **O(n log n)** 으로 비교적 시간복잡도가 준수함

## 최악의 경우 (O(n²))

```
이미 정렬된 배열에서 가장 오른쪽을 pivot으로 선택하는 경우

[1, 2, 3, 4, 5]
pivot = 5
→ [1, 2, 3, 4] | 5 | []  (불균형 분할)

[1, 2, 3, 4]
pivot = 4
→ [1, 2, 3] | 4 | []  (불균형 분할)

이런 식으로 계속 반복 → O(n²)
```

## pivot 선택 전략

| 전략 | 설명 | 장점 | 단점 |
|------|------|------|------|
| 맨 오른쪽 | 가장 오른쪽 원소 선택 | 구현 간단 | 정렬된 배열에서 최악 |
| 중간값 | 중간 위치 원소 선택 | 균형 잡힌 분할 가능 | 여전히 최악 가능 |
| 랜덤 | 랜덤 위치 선택 | 최악 확률 낮춤 | 추가 연산 필요 |
| 중앙값 (Median of Three) | 첫, 중간, 끝 중 중앙값 | 최악 회피 효과적 | 약간 복잡 |

## 장점
* **평균 O(n log n)**: 비교적 준수한 시간복잡도
* **제자리 정렬**: 추가 메모리가 적게 필요 (O(log n))
* **캐시 효율성**: 데이터 접근 패턴이 좋음
* **실제로 가장 빠른 정렬**: 평균적으로 다른 O(n log n) 정렬보다 빠름

## 단점
* **최악의 경우 O(n²)**: 이미 정렬된 경우
* **불안정 정렬**: 같은 값의 순서가 바뀔 수 있음
* **재귀 호출**: 스택 오버플로우 위험 (깊이가 깊을 때)

## 사용 가이드

### 언제 사용하면 좋은가?
* **일반적인 정렬 작업**에 가장 적합
* **평균적으로 빠른 성능**이 필요할 때
* **추가 메모리 사용을 최소화**해야 할 때
* **코딩 테스트**에서 직접 구현이 필요한 경우

### 언제 사용하지 말아야 하는가?
* **최악의 경우를 피해야** 할 때 (병합 정렬 고려)
* **안정 정렬**이 필요할 때 (병합 정렬 고려)
* **이미 정렬된 데이터**가 많을 때 (삽입 정렬 고려)

## 주의사항
* **pivot 선택이 중요**: 중앙값 선택 전략 권장
* **이미 정렬된 배열**: 최악의 경우 O(n²) 주의
* **재귀 깊이**: 스택 오버플로우 방지를 위해 깊이 제한 고려
* **불안정 정렬**: 같은 값의 순서가 보장되지 않음

## 최적화 기법

### 1. 작은 배열은 삽입 정렬
```java
if (right - left < 10) {
    insertionSort(arr, left, right);
    return;
}
```

### 2. Median of Three (중앙값)
```java
int mid = (left + right) / 2;
// arr[left], arr[mid], arr[right] 중 중앙값을 pivot으로
```

### 3. 3-way 파티션
```java
// 같은 값이 많을 때 효율적
// [작은 값] [같은 값] [큰 값] 3개 영역으로 분할
```

## 핵심 정리
* 퀵 정렬은 **pivot을 기준으로 분할하고 재귀적으로 정렬**
* **평균 O(n log n)** 으로 비교적 시간복잡도가 준수
* **최악의 경우 O(n²)** (이미 정렬된 경우)
* **pivot 선택 전략**이 성능에 큰 영향
