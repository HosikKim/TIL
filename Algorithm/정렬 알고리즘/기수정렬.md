# 기수 정렬 (Radix Sort)

## 개념
값을 비교하지 않고 자릿수를 기준으로 정렬하는 특이한 정렬 알고리즘

## 목적
* 비교 정렬의 한계(O(n log n))를 넘어서는 정렬
* 자릿수가 고정된 데이터를 빠르게 정렬
* 정수, 문자열 등 자릿수로 표현 가능한 데이터 정렬

## 핵심 아이디어
**값 전체를 비교하지 않고, 자릿수별로 분류하여 정렬**

## 정렬 과정

### 10개의 큐 사용
각 큐는 0~9까지의 자릿수를 대표 (한 자리에 0~9가 들어갈 수 있으므로 총 10개 필요)

```
큐 0: []
큐 1: []
큐 2: []
큐 3: []
큐 4: []
큐 5: []
큐 6: []
큐 7: []
큐 8: []
큐 9: []
```

### 동작 과정 예시
**초기 배열**: `[16, 80, 18, 77, 03, 24, 88, 23]`

#### 1단계: 일의 자릿수 기준으로 분류
```
16 → 6번 큐
80 → 0번 큐
18 → 8번 큐
77 → 7번 큐
03 → 3번 큐
24 → 4번 큐
88 → 8번 큐
23 → 3번 큐

큐 0: [80]
큐 1: []
큐 2: []
큐 3: [03, 23]
큐 4: [24]
큐 5: []
큐 6: [16]
큐 7: [77]
큐 8: [18, 88]
큐 9: []

큐에서 순서대로 꺼내기:
[80, 03, 23, 24, 16, 77, 18, 88]
```

#### 2단계: 십의 자릿수 기준으로 분류
```
80 → 8번 큐
03 → 0번 큐
23 → 2번 큐
24 → 2번 큐
16 → 1번 큐
77 → 7번 큐
18 → 1번 큐
88 → 8번 큐

큐 0: [03]
큐 1: [16, 18]
큐 2: [23, 24]
큐 3: []
큐 4: []
큐 5: []
큐 6: []
큐 7: [77]
큐 8: [80, 88]
큐 9: []

큐에서 순서대로 꺼내기:
[03, 16, 18, 23, 24, 77, 80, 88]

정렬 완료! ✅
```

## 전체 과정 요약

```
초기:        [16, 80, 18, 77, 03, 24, 88, 23]
             ↓
일의 자리:   [80, 03, 23, 24, 16, 77, 18, 88]
             ↓
십의 자리:   [03, 16, 18, 23, 24, 77, 80, 88]
             ↓
정렬 완료!
```

## 구현 코드

```java
public static void radixSort(int[] arr) {
    // 최댓값 찾기 (자릿수 결정)
    int max = Arrays.stream(arr).max().getAsInt();
    
    // 자릿수만큼 반복 (1의 자리, 10의 자리, 100의 자리...)
    for (int exp = 1; max / exp > 0; exp *= 10) {
        countingSort(arr, exp);
    }
}

private static void countingSort(int[] arr, int exp) {
    int n = arr.length;
    int[] output = new int[n];
    int[] count = new int[10];  // 0~9까지 10개
    
    // 현재 자릿수의 개수 세기
    for (int i = 0; i < n; i++) {
        int digit = (arr[i] / exp) % 10;
        count[digit]++;
    }
    
    // 누적 합 계산
    for (int i = 1; i < 10; i++) {
        count[i] += count[i - 1];
    }
    
    // 뒤에서부터 output 배열에 배치 (안정 정렬 유지)
    for (int i = n - 1; i >= 0; i--) {
        int digit = (arr[i] / exp) % 10;
        output[count[digit] - 1] = arr[i];
        count[digit]--;
    }
    
    // 원본 배열에 복사
    System.arraycopy(output, 0, arr, 0, n);
}
```

### 큐를 직접 사용하는 구현
```java
public static void radixSortWithQueue(int[] arr) {
    // 최댓값의 자릿수 구하기
    int max = Arrays.stream(arr).max().getAsInt();
    int maxDigit = String.valueOf(max).length();
    
    // 10개의 큐 생성
    Queue<Integer>[] queues = new LinkedList[10];
    for (int i = 0; i < 10; i++) {
        queues[i] = new LinkedList<>();
    }
    
    // 자릿수만큼 반복
    int divisor = 1;
    for (int d = 0; d < maxDigit; d++) {
        // 현재 자릿수를 기준으로 큐에 분류
        for (int num : arr) {
            int digit = (num / divisor) % 10;
            queues[digit].offer(num);
        }
        
        // 큐에서 순서대로 꺼내서 배열에 저장
        int index = 0;
        for (int i = 0; i < 10; i++) {
            while (!queues[i].isEmpty()) {
                arr[index++] = queues[i].poll();
            }
        }
        
        divisor *= 10;  // 다음 자릿수로
    }
}
```

## 시간복잡도 및 공간복잡도

| 항목 | 복잡도 | 비고 |
|------|--------|------|
| 시간복잡도 | O(k × n) | k는 데이터의 최대 자릿수 |
| 공간복잡도 | O(n + 10) | 임시 배열 + 10개 큐 |

**특징**: 비교 정렬이 아니므로 **O(n log n) 한계를 넘어설 수 있음**

### 시간복잡도 분석
```
데이터 개수: n
최대 자릿수: k

각 자릿수마다:
- n개의 데이터를 큐에 분류: O(n)
- n개의 데이터를 큐에서 꺼내기: O(n)

총 k번 반복 → O(k × n)

예시:
- 100개의 3자릿수 정수: O(3 × 100) = O(300)
- 100개의 일반 정렬: O(100 log 100) ≈ O(664)
→ 기수 정렬이 더 빠름!
```

## 장점
* **빠른 속도**: 자릿수가 적을 때 O(kn)으로 매우 빠름
* **비교 연산 없음**: 값을 직접 비교하지 않음
* **안정 정렬**: 같은 값의 순서가 유지됨
* **예측 가능**: 항상 O(kn) 성능

## 단점
* **추가 메모리 필요**: O(n) 공간 필요
* **자릿수에 의존**: 자릿수가 크면 비효율적
* **정수/문자열만 가능**: 실수나 복잡한 객체는 어려움
* **음수 처리 복잡**: 음수는 별도 처리 필요

## 자릿수가 성능에 미치는 영향

```
케이스 1: 1000개의 2자릿수 정수
O(2 × 1000) = O(2000)

케이스 2: 1000개의 10자릿수 정수
O(10 × 1000) = O(10000)

→ 자릿수가 클수록 느려짐
```


## 사용 가이드

### 언제 사용하면 좋은가?
* **자릿수가 제한적일 때** (k가 작을 때)
* **정수 데이터**를 정렬할 때
* **문자열 정렬** (고정 길이)
* **데이터 개수가 많고 자릿수가 적을 때**
* **안정 정렬**이 필요할 때

### 언제 사용하지 말아야 하는가?
* **자릿수가 매우 클 때** (전화번호, 주민등록번호 등)
* **실수 데이터**
* **메모리가 제한적일 때**
* **범용 정렬**이 필요할 때

## 활용 예시

### 1. 고정 길이 정수 정렬
```java
// 학번 정렬 (8자리 고정)
int[] studentIds = {20240101, 20240315, 20230512};
radixSort(studentIds);
```

### 2. 문자열 정렬
```java
// 고정 길이 문자열 (알파벳 26진수로 간주)
String[] words = {"cat", "dog", "bat", "ant"};
// 각 문자를 숫자로 변환하여 기수 정렬
```

### 3. 날짜 정렬
```java
// YYYYMMDD 형식 (8자리)
int[] dates = {20240101, 20231225, 20240315};
radixSort(dates);
```

## 주의사항

### 1. 음수 처리
```java
// 음수가 있는 경우
int[] arr = {-5, 3, -2, 8, 0};

// 방법 1: 최솟값을 더해서 모두 양수로 변환
// 방법 2: 음수와 양수를 따로 정렬
```

### 2. 자릿수 확인
```java
// 자릿수가 다른 경우 0으로 패딩
03 → 03
100 → 100 (자릿수가 다르면 더 긴 쪽 기준)
```

### 3. 안정 정렬 유지
```java
// 뒤에서부터 처리해야 안정 정렬 유지
for (int i = n - 1; i >= 0; i--) {
    // ...
}
```

## 최적화된 사용 조건

```
데이터 개수 n이 크고, 최대 자릿수 k가 작을 때 최적

예시:
✅ 좋음: n=1000000, k=3 → O(3000000)
❌ 나쁨: n=100, k=10 → O(1000)
        (차라리 퀵 정렬: O(100 log 100) ≈ O(664))

기준: k < log n 일 때 기수 정렬이 유리
```

## 핵심 정리
* 기수 정렬은 **값을 비교하지 않고 자릿수별로 분류**
* **10개의 큐**를 사용 (0~9 자릿수)
* **시간복잡도 O(kn)**: k는 최대 자릿수
* **자릿수가 적을 때** 매우 빠른 성능
* **안정 정렬**이며 추가 메모리 필요
* 정수, 문자열 등 **자릿수로 표현 가능한 데이터**에 적합