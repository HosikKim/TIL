# 선택 정렬 (Selection Sort)

## 개념
정렬되지 않은 부분에서 최솟값(또는 최댓값)을 찾아 맨 앞의 데이터와 swap하는 정렬 알고리즘

## 목적
* 단순하고 직관적인 정렬 방법 구현
* 정렬 알고리즘의 기본 원리 학습
* 메모리가 제한적인 환경에서 사용

## 정렬 과정

### 동작 단계
1. **남은 정렬 부분에서 최솟값(또는 최댓값) 찾기**
2. **찾은 값을 남은 정렬 부분의 가장 앞 데이터와 swap**
3. **정렬된 영역의 범위 확장** (index++)
4. **남은 정렬 부분이 없을 때까지 반복**

### 동작 과정 예시
**초기 배열**: `[5, 3, 8, 1, 2]` (오름차순 정렬)

```
1회전: 최솟값 1 찾기 → 맨 앞(5)과 swap
[5, 3, 8, 1, 2]
 ↓        ↑
[1, 3, 8, 5, 2]  → 정렬된 영역: [1]

2회전: 남은 부분[3,8,5,2]에서 최솟값 2 찾기 → 맨 앞(3)과 swap
[1, 3, 8, 5, 2]
    ↓        ↑
[1, 2, 8, 5, 3]  → 정렬된 영역: [1, 2]

3회전: 남은 부분[8,5,3]에서 최솟값 3 찾기 → 맨 앞(8)과 swap
[1, 2, 8, 5, 3]
       ↓     ↑
[1, 2, 3, 5, 8]  → 정렬된 영역: [1, 2, 3]

4회전: 남은 부분[5,8]에서 최솟값 5 찾기 → 이미 맨 앞
[1, 2, 3, 5, 8]  → 정렬된 영역: [1, 2, 3, 5]

5회전: 남은 부분[8] 1개 → 정렬 완료
[1, 2, 3, 5, 8]  → 정렬 완료
```

## 구현 코드

```java
public static void selectionSort(int[] arr) {
    int n = arr.length;
    
    // 정렬되지 않은 부분을 순회
    for (int i = 0; i < n - 1; i++) {
        int minIndex = i;  // 최솟값의 인덱스
        
        // 남은 정렬 부분에서 최솟값 찾기
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }
        
        // 최솟값을 맨 앞과 swap
        if (minIndex != i) {
            int temp = arr[i];
            arr[i] = arr[minIndex];
            arr[minIndex] = temp;
        }
    }
}
```

### 내림차순 (최댓값 찾기)
```java
// 최댓값을 찾아서 맨 앞에 배치
for (int j = i + 1; j < n; j++) {
    if (arr[j] > arr[maxIndex]) {  // 부등호만 변경
        maxIndex = j;
    }
}
```

## 시간복잡도 및 공간복잡도

| 경우 | 시간복잡도 | 비고 |
|------|-----------|------|
| 최악의 경우 | O(n²) | 모든 경우 동일 |
| 평균 | O(n²) | 모든 경우 동일 |
| 최선의 경우 | O(n²) | 이미 정렬되어도 동일 |
| 공간복잡도 | O(1) | 제자리 정렬 (in-place) |

**특징**: 데이터 상태와 무관하게 **항상 O(n²)**

## 장점
* **구현이 매우 간단**하고 이해하기 쉬움
* **제자리 정렬**(in-place): 추가 메모리 불필요
* **swap 횟수가 적음**: 각 회전마다 최대 1번만 swap (버블 정렬보다 적음)
* **불안정 정렬**이지만 안정화 가능

## 단점
* **시간복잡도 O(n²)**: 비효율적
* **이미 정렬된 경우에도 O(n²)**: 최적화 불가능 (버블 정렬은 O(n) 가능)
* **코딩 테스트에서 거의 사용하지 않음**

## 사용 가이드

### 언제 사용하면 좋은가?
* **데이터 개수가 매우 적을 때** (n < 20)
* **메모리가 극도로 제한적일 때** (O(1) 공간)
* **교육 목적**으로 정렬 원리를 학습할 때

### 언제 사용하지 말아야 하는가?
* **데이터 개수가 많을 때** (n > 100)
* **코딩 테스트**: 시간 초과 위험
* **거의 정렬된 데이터**: 삽입 정렬이 더 효율적

## 주의사항
* **불안정 정렬**: 같은 값의 순서가 바뀔 수 있음
  ```java
  [3a, 3b, 1] → [1, 3b, 3a]  // 3a와 3b 순서 바뀜
  ```
* **항상 O(n²)**: 데이터가 이미 정렬되어 있어도 개선 불가
* **코딩 테스트에서는 비추천**: 시간 초과 가능성 높음

## 핵심 정리
* 선택 정렬은 **최솟값을 찾아 맨 앞과 swap**하는 방식
* **시간복잡도 O(n²)로 비효율적**
* **코딩 테스트에서는 거의 사용하지 않음**

## 참고 자료
* 추천 문제: BOJ 2750 (수 정렬하기)