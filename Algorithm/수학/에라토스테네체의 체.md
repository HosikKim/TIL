# 에라토스테네스의 체 (Sieve of Eratosthenes)

## 개념
1과 자기 자신 외에 약수가 없는 소수를 효율적으로 찾는 알고리즘

## 목적
* 특정 범위 내의 모든 소수를 한 번에 찾기 위해
* 소수 판별을 반복적으로 수행할 때 효율성 확보
* 일반적인 소수 판별법(O(N√N))보다 빠른 성능 제공

## 알고리즘 원리

### 수행 과정
```
1. 구하고자 하는 범위만큼 1차원 배열 생성
2. 2부터 시작하여 현재 숫자가 지워지지 않았다면:
   - 현재 숫자는 소수로 확정 (지우지 않음)
   - 현재 숫자의 배수들을 배열 끝까지 탐색하며 모두 삭제
3. 배열 끝까지 반복 후 남아있는 수가 모든 소수
```
### 코드 예시
```java
boolean[] prime = new boolean[n + 1];
Arrays.fill(prime, true);
prime[0] = prime[1] = false;  // 0, 1은 소수 아님

for (int i = 2; i * i <= n; i++) {
    if (prime[i]) {  // 지워지지 않은 수
        for (int j = i * i; j <= n; j += i) {
            prime[j] = false;  // 배수 삭제
        }
    }
}
```

## 동작 예시 (1~30 범위)

| 단계 | 선택된 수 | 삭제되는 수 | 남은 소수 후보 |
|------|-----------|-------------|----------------|
| 초기 | - | 1 | 2, 3, 4, 5, ..., 30 |
| 1단계 | 2 | 4, 6, 8, 10, ... | 2, 3, 5, 7, 9, 11, ... |
| 2단계 | 3 | 9, 15, 21, 27 | 2, 3, 5, 7, 11, 13, ... |
| 3단계 | 5 | 25 | 2, 3, 5, 7, 11, 13, ... |
| 결과 | - | - | 2, 3, 5, 7, 11, 13, 17, 19, 23, 29 |

## 시간 복잡도

| 복잡도 유형 | 값 | 설명 |
|-------------|-----|------|
| 시간 복잡도 | **O(N log (log N))** | 이중 for문이지만 배수 삭제로 인한 연산 생략 |
| 공간 복잡도 | O(N) | 범위만큼의 boolean 배열 필요 |
| 일반 판별법 | O(N√N) | 각 수마다 √N까지 나눗셈 필요 |

## 장점
* 특정 범위의 모든 소수를 한 번에 구할 수 있음
* 여러 소수 판별이 필요할 때 효율적
* 구현이 직관적이고 간단함

## 단점 및 주의사항
* 범위가 클수록 메모리 사용량 증가 (배열 크기)
* 단일 소수 판별에는 비효율적 (전체 범위를 계산해야 함)
* int 범위를 넘어가는 큰 수에는 적용 어려움

## 사용 가이드

### 언제 사용하면 좋은가?
* 특정 범위(1~N) 내의 모든 소수가 필요할 때
* 소수 판별을 여러 번 해야 할 때
* 코딩 테스트에서 소수 관련 문제

### 언제 사용하지 말아야 하는가?
* 단일 수의 소수 판별만 필요할 때
* 메모리 제약이 심할 때
* 범위가 10^9 이상으로 매우 클 때

## 최적화 팁
* 바깥 for문: `i * i <= n` 조건으로 불필요한 반복 제거
* 안쪽 for문: `j = i * i`부터 시작 (i*2, i*3...는 이미 처리됨)
* 짝수 제외: 2 처리 후 홀수만 체크하면 연산 절반 감소

## 참고 자료
* 백준 소수 구하기 문제 : 1929
```java
import java.util.Arrays;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int M = sc.nextInt();
        int N = sc.nextInt();

        boolean[] prime = new boolean[N + 1];
        Arrays.fill(prime, true);
        // 0과 1은 소수에서 제외
        prime[0] = prime[1] = false;

        // i<=N 보다 i*i<=N 이 훨씬 효율적
        for (int i = 2; i * i <= N; i++) {
            if (prime[i]) {
                for (int j = i * i; j <= N; j += i) {
                    prime[j] = false;
                }
            }
        }

        for (int i = M; i <= N; i++) {
            if (prime[i]) {
                System.out.println(i);
            }
        }
    }
}

```