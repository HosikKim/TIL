# 유클리드 호제법 (Euclidean Algorithm)

## 개념
두 수의 최대공약수(GCD)를 MOD 연산을 반복하여 효율적으로 구하는 알고리즘

## 목적
* 소인수분해 방식보다 빠르고 간단하게 GCD 계산
* 큰 수의 최대공약수를 효율적으로 구함
* 재귀적 구조로 구현이 간결함

## MOD 연산
두 값을 나눈 나머지를 구하는 연산
```
10 MOD 4 = 2
270 MOD 192 = 78
```

## 알고리즘 단계

| 단계 | 작업 | 설명 |
|------|------|------|
| 1 | 큰 수 % 작은 수 | MOD 연산 수행 |
| 2 | 작은 수 % 나머지 | 이전 나머지를 새로운 제수로 사용 |
| 3 | 반복 | 나머지가 0이 될 때까지 2단계 반복 |
| 4 | 종료 | 나머지가 0일 때의 제수가 GCD |

## 실행 예시
```
GCD(270, 192) 구하기

270 % 192 = 78
192 % 78 = 36
78 % 36 = 6
36 % 6 = 0

∴ GCD(270, 192) = 6
```

## 코드 구현

### 반복문 방식
```java
int gcd(int a, int b) {
    while (b != 0) {
        int temp = a % b;
        a = b;
        b = temp;
    }
    return a;
}
```

### 재귀 방식
```java
int gcd(int a, int b) {
    return (b == 0) ? a : gcd(b, a % b);
}
```

## 시간 복잡도
| 항목 | 복잡도 | 설명 |
|------|--------|------|
| 시간 | O(log(min(a, b))) | 피보나치 수열의 성장률과 관련 |
| 공간 | O(1) | 반복문 / O(log n) 재귀 |

## 장점
* 소인수분해보다 훨씬 빠름
* 구현이 간단하고 직관적
* 큰 수에도 효율적으로 동작

## 사용 가이드

### 언제 사용하면 좋은가?
* 최대공약수(GCD) 계산이 필요할 때
* 최소공배수(LCM) 계산 시 (LCM = a × b / GCD)
* 분수 약분이 필요할 때
* 암호학 알고리즘 (RSA 등)

### 주의사항
* 입력값이 0이 되지 않도록 처리
* 음수 입력 시 절댓값 변환 필요

## 참고
* 최소공배수 공식: `LCM(a, b) = (a × b) / GCD(a, b)`
* 백준 최대공약수와 최소공배수 : 2609
```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int num1 = sc.nextInt();
        int num2 = sc.nextInt();

        int gcd = GCD(num1, num2);
        int lcm = (num1 * num2) / gcd;

        System.out.println(gcd);
        System.out.println(lcm);
    }

    public static int GCD(int a, int b) {
        while (b != 0) {
            int temp = a % b;
            a = b;
            b = temp;
        }

        return a;
    }
}
```