# 시간 복잡도 (Time Complexity)

## 개념
알고리즘이 문제를 해결하기 위해 수행하는 연산 횟수를 나타내는 지표

## 목적
* 알고리즘 효율성 평가
* 입력 크기에 따른 성능 예측
* 최적의 알고리즘 선택 기준 제공

## 수행 시간 예측
일반적으로 **1억 번(10^8)의 연산을 1초**로 간주하여 실행 시간을 예측

```
입력 크기 N = 1,000,000
시간복잡도 O(N) → 약 0.01초
시간복잡도 O(N²) → 약 10,000초 (불가능)
```

## 시간 복잡도 유형

### 1. Big-Omega (Ω) - 최선의 경우
정의: 알고리즘의 최소 실행 시간 (하한선)

### 2. Big-Theta (Θ) - 평균의 경우
정의: 알고리즘의 평균 실행 시간

### 3. Big-O (O) - 최악의 경우
정의: 알고리즘의 최대 실행 시간 (상한선)
**→ 문제 풀이에서 일반적으로 사용**

## Big-O 표기법 복잡도 순서

```
O(1) < O(log N) < O(N) < O(N log N) < O(N²) < O(N³) < O(2^N) < O(N!)
```

**빠름 ←――――――――――――――――――――――――――――――――→ 느림**

## 중요한 특징

### 최고차항만 표기
```java
// O(3N² + 5N + 10) → O(N²)
// 계수와 낮은 차수 항은 생략
```

### 반복문과 시간복잡도
**핵심**: 중첩 깊이가 시간복잡도를 결정

```
❌ 일중 for문 100개 → O(N) (순차적 실행)
✅ 이중 for문 1개 → O(N²) (중첩 실행)

이유: 
- for문 100개: N + N + ... + N = 100N → O(N)
- 이중 for문 1개: N × N → O(N²)
```

## 주요 시간복잡도 비교

| 표기법 | 명칭 | 설명 | 예시 (N=1,000,000) |
|--------|------|------|-------------------|
| O(1) | 상수 시간 | 입력 크기와 무관 | 1번 |
| O(log N) | 로그 시간 | 입력이 절반씩 감소 | 약 20번 |
| O(N) | 선형 시간 | 입력에 비례 | 1,000,000번 |
| O(N log N) | 선형로그 시간 | 효율적인 정렬 | 약 20,000,000번 |
| O(N²) | 이차 시간 | 이중 반복 | 1,000,000,000,000번 |
| O(N³) | 삼차 시간 | 삼중 반복 | 10^18번 |
| O(2^N) | 지수 시간 | 매우 비효율적 | 거의 불가능 |
| O(N!) | 팩토리얼 시간 | 극도로 비효율적 | 완전히 불가능 |

## 알고리즘별 시간복잡도

| 알고리즘 | 최선 | 평균 | 최악 | 공간복잡도 |
|----------|------|------|------|------------|
| **정렬 알고리즘** |
| 버블 정렬 | O(N) | O(N²) | O(N²) | O(1) |
| 선택 정렬 | O(N²) | O(N²) | O(N²) | O(1) |
| 삽입 정렬 | O(N) | O(N²) | O(N²) | O(1) |
| 합병 정렬 | O(N log N) | O(N log N) | O(N log N) | O(N) |
| 퀵 정렬 | O(N log N) | O(N log N) | O(N²) | O(log N) |
| 힙 정렬 | O(N log N) | O(N log N) | O(N log N) | O(1) |
| **탐색 알고리즘** |
| 선형 탐색 | O(1) | O(N) | O(N) | O(1) |
| 이진 탐색 | O(1) | O(log N) | O(log N) | O(1) |
| 해시 탐색 | O(1) | O(1) | O(N) | O(N) |
| **자료구조 연산** |
| 배열 접근 | O(1) | O(1) | O(1) | - |
| 배열 탐색 | O(1) | O(N) | O(N) | - |
| 배열 삽입/삭제 | O(1) | O(N) | O(N) | - |
| 연결 리스트 접근 | O(1) | O(N) | O(N) | - |
| 연결 리스트 삽입/삭제 | O(1) | O(1) | O(1) | - |
| 스택/큐 삽입/삭제 | O(1) | O(1) | O(1) | - |
| **그래프 알고리즘** |
| BFS (너비 우선 탐색) | - | O(V + E) | O(V + E) | O(V) |
| DFS (깊이 우선 탐색) | - | O(V + E) | O(V + E) | O(V) |
| 다익스트라 | - | O(E log V) | O(E log V) | O(V) |
| 벨만-포드 | - | O(VE) | O(VE) | O(V) |
| 플로이드-워셜 | - | O(V³) | O(V³) | O(V²) |

*V: 정점(Vertex) 개수, E: 간선(Edge) 개수*

## 문제 풀이 가이드

### 입력 크기별 권장 시간복잡도

| 입력 크기 N | 권장 시간복잡도 | 알고리즘 예시 |
|-------------|-----------------|---------------|
| N ≤ 10 | O(N!) | 순열, 조합 (완전탐색) |
| N ≤ 20 | O(2^N) | 비트마스킹, 백트래킹 |
| N ≤ 500 | O(N³) | 플로이드-워셜, 3중 반복문 |
| N ≤ 5,000 | O(N²) | 버블/선택 정렬, DP |
| N ≤ 100,000 | O(N log N) | 합병/퀵/힙 정렬, 이진 탐색 |
| N ≤ 1,000,000 | O(N) | 선형 탐색, 단일 반복문 |
| N > 1,000,000 | O(log N) 또는 O(1) | 이진 탐색, 해시, 수학적 공식 |

### 시간 초과 해결 전략

1. **시간복잡도 계산**: 현재 알고리즘의 복잡도 확인
2. **불필요한 연산 제거**: 중복 계산 제거 (메모이제이션)
3. **더 효율적인 알고리즘 선택**: O(N²) → O(N log N)
4. **자료구조 변경**: 배열 → 해시맵/세트
5. **조기 종료 조건 추가**: break, continue 활용

## 주의사항

### 상수 시간도 중요
```
O(N)이어도 실제로는:
- 100N vs 5N → 20배 차이
- 실제 구현에서 상수 계수도 고려 필요
```

### 공간복잡도와의 트레이드오프
```
시간을 줄이면 메모리 사용 증가 (메모이제이션)
메모리를 줄이면 시간 증가 (재계산)
```

### 실제 실행 시간 ≠ 시간복잡도
```
- 캐시 효율성
- 분기 예측
- 컴파일러 최적화
→ 이론과 실제는 차이 있을 수 있음
```

## 참고 자료
* [Big-O Cheat Sheet](https://www.bigocheatsheet.com/)
* [시간 복잡도 시각화](https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html)

