# 스택(Stack)과 큐(Queue)

## 개념
데이터의 삽입과 삭제 순서가 정해진 선형 자료구조

## 목적
* 데이터의 처리 순서를 제어하기 위해 사용
* 알고리즘 구현 시 특정 순서로 데이터를 처리해야 할 때 활용
* 각각 DFS/BFS 등 탐색 알고리즘의 핵심 자료구조

## 스택(Stack)

### 특징
* **후입선출(LIFO: Last In First Out)** 구조
* 한쪽 끝에서만 삽입과 삭제가 일어남
* 재귀 함수의 동작 원리와 동일한 메커니즘

### 주요 연산
```java
Stack<Integer> stack = new Stack<>();

stack.push(1);      // 삽입: [1]
stack.push(2);      // 삽입: [1, 2]
stack.push(3);      // 삽입: [1, 2, 3]
stack.pop();        // 삭제 및 반환: 3 → [1, 2]
stack.peek();       // 최상단 조회: 2
stack.isEmpty();    // 비어있는지 확인
stack.size();       // 스택의 크기 확인 
```

### 주요 활용
* **DFS (깊이 우선 탐색)**
* **백트래킹 알고리즘**
* 괄호 짝 맞추기
* 함수 호출 스택
* 실행 취소(Undo) 기능

## 큐(Queue)

### 특징
* **선입선출(FIFO: First In First Out)** 구조
* 양방향에서 삽입과 삭제가 일어남 (rear에서 삽입, front에서 삭제)
* 먼저 들어온 데이터가 먼저 나감

### 주요 연산
```java
Queue<Integer> queue = new LinkedList<>();

queue.offer(1);     // 삽입(rear): [1]
queue.offer(2);     // 삽입(rear): [1, 2]
queue.offer(3);     // 삽입(rear): [1, 2, 3]
queue.poll();       // 삭제(front): 1 → [2, 3]
queue.peek();       // 최앞단 조회: 2
queue.isEmpty();    // 비어있는지 확인
queue.size();       // 큐의 크기 확인
```

### 주요 활용
* **BFS (너비 우선 탐색)**
* 프로세스 스케줄링
* 캐시 구현
* 프린터 대기열
* 버퍼(Buffer) 구조

## 스택 vs 큐 비교

| 구분 | 스택(Stack) | 큐(Queue) |
|------|------------|-----------|
| 동작 방식 | 후입선출(LIFO) | 선입선출(FIFO) |
| 삽입/삭제 위치 | 한쪽 끝(top) | 양쪽 끝(rear/front) |
| 주요 연산 | push(), pop() | offer(), poll() |
| 대표 알고리즘 | DFS, 백트래킹 | BFS, 레벨 순회 |
| 재귀와의 관계 | 재귀 함수 원리와 동일 | 반복적 처리에 적합 |

## 우선순위 큐 (Priority Queue)

### 개념
* 일반 큐와 달리 **우선순위가 높은 데이터가 먼저 나오는** 자료구조
* 내부적으로 **힙(Heap)** 자료구조로 구현됨
* 삽입 순서와 무관하게 우선순위에 따라 데이터 처리

```java
PriorityQueue<Integer> pq = new PriorityQueue<>();  // 최소 힙
pq.offer(5);
pq.offer(2);
pq.offer(8);
pq.poll();  // 2가 나옴 (가장 작은 값)
```

### 활용
* 다익스트라 최단 경로 알고리즘
* 작업 스케줄링
* K번째 최소/최대값 찾기

> **Note**: 우선순위 큐와 힙은 별도 TIL에서 자세히 다룰 예정

## 사용 가이드

### 스택을 사용해야 할 때
* 가장 최근 데이터를 먼저 처리해야 할 때
* 역순으로 데이터를 처리해야 할 때
* 재귀적 구조를 반복문으로 변환할 때
* DFS, 백트래킹 문제

### 큐를 사용해야 할 때
* 데이터를 입력 순서대로 처리해야 할 때
* 레벨별로 탐색해야 할 때 (레벨 순서 탐색)
* BFS 문제
* 시뮬레이션 문제 (대기열 처리)

### 우선순위 큐를 사용해야 할 때
* 최소/최대값을 반복적으로 꺼내야 할 때
* 정렬 상태를 유지하며 삽입/삭제가 빈번할 때
* 최단 경로, 최소 비용 문제

## 시간복잡도

| 연산 | 스택 | 큐 | 우선순위 큐 |
|------|------|-----|------------|
| 삽입 | O(1) | O(1) | O(log N) |
| 삭제 | O(1) | O(1) | O(log N) |
| 조회 | O(1) | O(1) | O(1) |

## 주의사항
* 빈 스택/큐에서 pop/poll 시 예외 발생 주의 (`isEmpty()` 체크 필수)

## 참고 자료
* 관련 자료구조: Deque(덱), 우선순위 큐, 힙
* 관련 알고리즘: DFS, BFS, 백트래킹, 다익스트라
* 추천 문제: BOJ 10828 (스택)