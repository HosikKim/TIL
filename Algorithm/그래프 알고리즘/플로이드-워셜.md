# 플로이드-워셜 (Floyd-Warshall) 알고리즘

## 개념
모든 노드 간의 최단 거리를 구하는 알고리즘 (동적 계획법 기반)

## 목적
* 모든 노드 쌍의 최단 경로 계산
* 음수 가중치 그래프 처리
* 그래프 연결성 확인
* 경유지를 고려한 최적 경로 탐색

## 핵심 특징

| 특징 | 설명 |
|------|------|
| 시작점 | **모든 노드 쌍** (다익스트라/벨만-포드와 차이) |
| 에지 가중치 | 음수 가능 (단, 음수 사이클 불가) |
| 시간 복잡도 | **O(V³)** |
| 자료구조 | 2차원 배열 (인접 행렬) |
| 알고리즘 기법 | 동적 계획법 (DP) |

## 최단 거리 알고리즘 비교

| 알고리즘 | 시작점 | 음수 에지 | 시간 복잡도 | 자료구조 |
|---------|--------|----------|------------|---------|
| 다익스트라 | 1개 | ✗ | O(E log V) | 인접 리스트 |
| 벨만-포드 | 1개 | ✓ | O(VE) | 에지 리스트 |
| 플로이드-워셜 | 모든 쌍 | ✓ | O(V³) | 인접 행렬 |

## 핵심 원리

**A → B 최단 경로에 K 노드가 존재한다면, 부분 경로도 최단 경로다**

즉, K를 거쳐 가는 것이 직접 가는 것보다 빠르면 갱신

**점화식**
```
D[S][E] = Math.min(D[S][E], D[S][K] + D[K][E])
```

## 구현 방법

### 1. 인접 행렬 선언 및 초기화

```java
int[][] dist = new int[n + 1][n + 1];

// 초기화
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= n; j++) {
        if (i == j) {
            dist[i][j] = 0;  // 자기 자신
        } else {
            dist[i][j] = INF;  // 무한대
        }
    }
}
```

### 2. 그래프 데이터 저장

```java
// 에지 정보 입력
dist[s][e] = w;  // s → e, 가중치 w
```

### 3. 3중 for문으로 점화식 적용

```java
// 경유지 K를 기준으로 순회 (가장 바깥 루프!)
for (int k = 1; k <= n; k++) {
    // 출발 노드 S
    for (int s = 1; s <= n; s++) {
        // 도착 노드 E
        for (int e = 1; e <= n; e++) {
            // K를 거쳐가는 것이 더 빠르면 갱신
            dist[s][e] = Math.min(dist[s][e], 
                                  dist[s][k] + dist[k][e]);
        }
    }
}
```

## 완전한 구현 코드

```java
class FloydWarshall {
    static final int INF = 100_000_000;
    static int n;
    static int[][] dist;
    
    public static void main(String[] args) {
        n = 5;
        dist = new int[n + 1][n + 1];
        
        // 1. 초기화
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                if (i == j) dist[i][j] = 0;
                else dist[i][j] = INF;
            }
        }
        
        // 2. 그래프 입력
        dist[1][2] = 8;
        dist[1][3] = 3;
        dist[2][4] = 4;
        // ...
        
        // 3. 플로이드-워셜 실행
        floydWarshall();
        
        // 결과 출력
        printResult();
    }
    
    static void floydWarshall() {
        for (int k = 1; k <= n; k++) {
            for (int s = 1; s <= n; s++) {
                for (int e = 1; e <= n; e++) {
                    dist[s][e] = Math.min(dist[s][e], 
                                          dist[s][k] + dist[k][e]);
                }
            }
        }
    }
    
    static void printResult() {
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                if (dist[i][j] == INF) System.out.print("INF ");
                else System.out.print(dist[i][j] + " ");
            }
            System.out.println();
        }
    }
}
```

## 동작 과정 예시

**초기 그래프: 1→2(8), 1→3(3), 2→4(4), 3→4(7)**

**초기 상태 (K=0)**
```
    1   2   3   4
1 [ 0   8   3  INF]
2 [INF  0  INF  4 ]
3 [INF INF  0   7 ]
4 [INF INF INF  0 ]
```

**K=1 (1번 노드 경유)**
```
    1   2   3   4
1 [ 0   8   3  INF]
2 [INF  0  INF  4 ]
3 [INF INF  0   7 ]
4 [INF INF INF  0 ]
```

**K=2 (2번 노드 경유)**
```
    1   2   3   4
1 [ 0   8   3  12 ]  // 1→2→4 = 12
2 [INF  0  INF  4 ]
3 [INF INF  0   7 ]
4 [INF INF INF  0 ]
```

**K=3 (3번 노드 경유)**
```
    1   2   3   4
1 [ 0   8   3  10 ]  // 1→3→4 = 10 (갱신!)
2 [INF  0  INF  4 ]
3 [INF INF  0   7 ]
4 [INF INF INF  0 ]
```


## 중요 포인트

| 포인트 | 설명 |
|--------|------|
| 3중 for문 순서 | **경유지 K가 가장 바깥!** |
| 초기화 | 자기 자신 0, 나머지 INF |
| 노드 수 제한 | N이 작을 때만 사용 (보통 N ≤ 500) |
| 음수 사이클 | dist[i][i] < 0이면 존재 |

## 장점
* 구현이 매우 간단 (3중 for문)
* 모든 쌍의 최단 거리를 한 번에 계산
* 음수 가중치 처리 가능
* 코드가 짧고 이해하기 쉬움

## 단점 및 주의사항
* **O(V³)로 느림** - 노드가 많으면 사용 불가
* 메모리 사용량 O(V²) - 큰 그래프에 비효율적
* 음수 사이클 존재 시 최단 거리 무의미
* 보통 **N ≤ 500** 정도만 사용 가능


## 음수 사이클 확인

```java
// 플로이드-워셜 실행 후
boolean hasNegativeCycle = false;
for (int i = 1; i <= n; i++) {
    if (dist[i][i] < 0) {
        hasNegativeCycle = true;
        break;
    }
}
```

자기 자신으로 돌아오는 거리가 음수면 음수 사이클 존재

## 왜 경유지 K가 가장 바깥 루프인가?

DP의 부분 문제 정의:
- `D[k][s][e]`: k번까지 경유지로 고려했을 때 s→e 최단거리
- K를 순차적으로 늘려가며 최적해 구축
- K-1까지의 결과를 바탕으로 K번 경유 고려

## 초기화 예시
```java
final int INF = 100_000_000; // 충분히 큰 값

int[][] dist = new int[n + 1][n + 1];
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= n; j++) {
        if (i == j) dist[i][j] = 0;
        else dist[i][j] = INF;
    }
}

// 양방향 그래프
dist[a][b] = cost;
dist[b][a] = cost;
```

## 참고 자료
* 백준 플로이드-워셜 문제: 11404(플로이드)
```java
import java.util.*;
import java.io.*;

public class Main {
    static final int INF = 100_000_000;
    static int[][] dist;
    static int n, m;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        n = Integer.parseInt(br.readLine());
        m = Integer.parseInt(br.readLine());

        dist = new int[n + 1][n + 1];

        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                if (i == j) {
                    dist[i][j] = 0;
                } else {
                    dist[i][j] = INF;
                }
            }
        }

        for (int i = 1; i <= m; i++) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            int start = Integer.parseInt(st.nextToken());
            int end = Integer.parseInt(st.nextToken());
            int weight = Integer.parseInt(st.nextToken());
            dist[start][end] = Math.min(dist[start][end], weight);
        }
        floydWarshall();
        output();

    }

    static void floydWarshall() {
        for (int k = 1; k <= n; k++) {
            for (int s = 1; s <= n; s++) {
                for (int e = 1; e <= n; e++) {
                    dist[s][e] = Math.min(dist[s][e], dist[s][k] + dist[k][e]);
                }
            }
        }
    }

    static void output() {
        StringBuilder sb = new StringBuilder();
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                if (dist[i][j] == INF) {
                    sb.append(0).append(" ");
                } else {
                    sb.append(dist[i][j] + " ");
                }
            }
            sb.append("\n");
        }

        System.out.println(sb);
    }
}
```
**MAX_VALUE 사용시 Integer 오버플로우**
계산식에서 MAX_VALUE + 일반값이 int 범위 초과하여 음수로 변환
INF 상수를 만들어 임의 값 넣어 주어야함