# 다익스트라 (Dijkstra) 알고리즘

## 개념
시작 노드에서 다른 모든 노드까지의 최단 거리를 구하는 알고리즘

## 목적
* 가중치 그래프에서 최단 경로 찾기
* 네비게이션, 네트워크 라우팅
* 게임 AI의 경로 탐색
* 음수 에지가 없는 최단 거리 문제

## 핵심 특징

| 특징 | 설명 |
|------|------|
| 에지 가중치 | **양수만 가능** (음수 불가) |
| 시간 복잡도 | **O(E log V)** |
| 자료구조 | 우선순위 큐 (최소 힙) |
| 탐욕 알고리즘 | 매번 최단 거리 노드 선택 |

## 5단계 알고리즘

### 1. 인접 리스트로 그래프 구현
```java
class Node implements Comparable<Node> {
    int vertex;
    int cost;
    
    Node(int v, int c) {
        this.vertex = v;
        this.cost = c;
    }
    
    @Override
    public int compareTo(Node o) {
        return this.cost - o.cost;
    }
}

ArrayList<Node>[] graph = new ArrayList[n + 1];
// 1 -> [2,8], [3,3]
graph[1].add(new Node(2, 8));
graph[1].add(new Node(3, 3));
```

### 2. 최단 거리 배열 초기화
```java
int[] dist = new int[n + 1];
Arrays.fill(dist, Integer.MAX_VALUE);
dist[start] = 0;  // 시작 노드는 0
```

| 노드 | 1 | 2 | 3 | 4 | 5 |
|-----|---|---|---|---|---|
| 초기값 | 0 | ∞ | ∞ | ∞ | ∞ |

### 3. 값이 가장 작은 노드 고르기
우선순위 큐를 사용하여 자동으로 최소값 선택

### 4. 최단 거리 배열 업데이트
선택된 노드와 연결된 노드들의 거리 갱신

### 5. 과정 3~4 반복하여 완성

## 구현 방법

```java
static void dijkstra(int start) {
    PriorityQueue<Node> pq = new PriorityQueue<>();
    boolean[] visited = new boolean[n + 1];
    
    pq.offer(new Node(start, 0));
    dist[start] = 0;
    
    while (!pq.isEmpty()) {
        Node now = pq.poll();
        
        if (visited[now.vertex]) continue;
        visited[now.vertex] = true;
        
        for (Node next : graph[now.vertex]) {
            if (dist[next.vertex] > dist[now.vertex] + next.cost) {
                dist[next.vertex] = dist[now.vertex] + next.cost;
                pq.offer(new Node(next.vertex, dist[next.vertex]));
            }
        }
    }
}
```

## 동작 과정 예시

**그래프: 1→2(8), 1→3(3), 3→4(13), 2→4(4), 2→5(15), 4→5(2)**

| 단계 | 선택 노드 | 거리 배열 [1, 2, 3, 4, 5] |
|-----|----------|------------------------|
| 초기 | - | [0, ∞, ∞, ∞, ∞] |
| 1 | 1 | [0, 8, 3, ∞, ∞] |
| 2 | 3 | [0, 8, 3, 16, ∞] |
| 3 | 2 | [0, 8, 3, 12, 23] |
| 4 | 4 | [0, 8, 3, 12, 14] |
| 5 | 5 | [0, 8, 3, 12, 14] |

## 시간/공간 복잡도

| 복잡도 | 값 | 설명 |
|--------|-----|------|
| 시간 복잡도 | O(E log V) | 우선순위 큐 사용 시 |
| 공간 복잡도 | O(V) | 거리 배열 + 방문 배열 |

* 우선순위 큐 미사용 시: O(V²)

## 필수 요소

| 요소 | 설명 | 이유 |
|------|------|------|
| dist 배열 | 최단 거리 저장 | 각 노드까지 최단 거리 기록 |
| 우선순위 큐 | 최소 거리 노드 선택 | O(log V) 시간에 최소값 추출 |
| visited 배열 | 방문 체크 | 중복 처리 방지 |
| 인접 리스트 | 그래프 표현 | 메모리 효율 + 빠른 탐색 |

## 장점
* 양수 가중치 그래프에서 최적 해 보장
* 우선순위 큐로 효율적 구현 (O(E log V))
* 한 번 실행으로 모든 노드까지 최단 거리 계산

## 단점 및 주의사항
* **음수 가중치 에지 불가능** (벨만-포드 사용 필요)
* 시작 노드 하나에서만 최단 거리 계산 (모든 쌍은 플로이드-워셜)
* 우선순위 큐 미사용 시 O(V²)로 느려짐
* Integer.MAX_VALUE 사용 시 오버플로 주의

## 사용 가이드

### 언제 사용하면 좋은가?
* 최단 경로 문제 (네비게이션)
* 네트워크 라우팅
* 가중치가 모두 양수인 그래프
* 한 시작점에서 모든 노드까지의 거리

### 언제 사용하지 말아야 하는가?
* 음수 가중치 에지 존재 → **벨만-포드** 사용
* 모든 노드 쌍의 최단 거리 필요 → **플로이드-워셜** 사용
* 가중치 없는 그래프 → **BFS**가 더 간단

## 그래프 초기화 예시
```java
// 인접 리스트 초기화
ArrayList<Node>[] graph = new ArrayList[n + 1];
for (int i = 1; i <= n; i++) {
    graph[i] = new ArrayList<>();
}

// 에지 추가 (양방향인 경우)
graph[a].add(new Node(b, cost));
graph[b].add(new Node(a, cost));

// 최단 거리 배열 초기화
int[] dist = new int[n + 1];
Arrays.fill(dist, Integer.MAX_VALUE);
dist[start] = 0;
```

## 핵심 포인트
* **우선순위 큐**: 최소 거리 노드를 자동으로 선택
* **거리 갱신 조건**: `dist[next] > dist[now] + cost`
* **visited 체크**: 이미 확정된 노드는 다시 처리 안 함
* **양수 에지 전용**: 음수가 있으면 동작 안 함!

## 참고 자료
* 백준 다익스트라 문제: 1916(최소비용 구하기)
```java
import java.io.*;
import java.util.*;

class Node implements Comparable<Node> {
    int edge;
    int cost;

    Node(int v, int c) {
        this.edge = v;
        this.cost = c;
    }

    @Override
    public int compareTo(Node o) {
        return this.cost - o.cost;
    }

}

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        int N = Integer.parseInt(br.readLine());
        int M = Integer.parseInt(br.readLine());
        ArrayList<Node>[] graph = new ArrayList[N + 1];

        for (int i = 1; i <= N; i++) {
            graph[i] = new ArrayList<>();
        }

        for (int i = 0; i < M; i++) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            int city = Integer.parseInt(st.nextToken());
            int edge = Integer.parseInt(st.nextToken());
            int cost = Integer.parseInt(st.nextToken());
            graph[city].add(new Node(edge, cost));
        }

        StringTokenizer st = new StringTokenizer(br.readLine());
        int start = Integer.parseInt(st.nextToken());
        int end = Integer.parseInt(st.nextToken());

        int result = dijkstra(graph, start, end);
        System.out.println(result);
    }

    public static int dijkstra(ArrayList<Node>[] graph, int start, int end) {
        int[] distance = new int[graph.length];
        Arrays.fill(distance, Integer.MAX_VALUE);
        distance[start] = 0;

        PriorityQueue<Node> pq = new PriorityQueue<>();
        boolean[] visited = new boolean[distance.length];

        pq.offer(new Node(start, 0));

        while (!pq.isEmpty()) {
            Node now = pq.poll();

            if (visited[now.edge])
                continue;
            visited[now.edge] = true;

            for (Node next : graph[now.edge]) {
                if (distance[next.edge] > distance[now.edge] + next.cost) {
                    distance[next.edge] = distance[now.edge] + next.cost;
                    pq.offer(new Node(next.edge, distance[next.edge]));
                }
            }
        }

        return distance[end];

    }
}

```