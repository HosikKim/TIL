# 벨만-포드 (Bellman-Ford) 알고리즘

## 개념
음수 가중치 에지가 있어도 최단 거리를 구할 수 있고, 음수 사이클 존재 여부를 판단하는 알고리즘

## 목적
* 음수 가중치 그래프에서 최단 경로 찾기
* 음수 사이클 탐지
* 다익스트라가 불가능한 상황에서 최단 거리 계산
* 네트워크 라우팅 (음수 비용 처리)

## 핵심 특징

| 특징 | 설명 |
|------|------|
| 에지 가중치 | **음수 가능** (다익스트라와 차이) |
| 시간 복잡도 | **O(VE)** |
| 자료구조 | 에지 리스트 |
| 음수 사이클 | 탐지 가능 |

## 다익스트라와의 비교

| 항목 | 다익스트라 | 벨만-포드 |
|------|-----------|----------|
| 음수 에지 | ✗ 불가능 | ✓ 가능 |
| 시간 복잡도 | O(E log V) | O(VE) |
| 그래프 구현 | 인접 리스트 | 에지 리스트 |
| 음수 사이클 | 탐지 불가 | 탐지 가능 |

## 3단계 알고리즘

### 1. 에지 리스트로 그래프 구현 및 초기화

**에지 리스트 구조**
```java
class Edge {
    int start;
    int end;
    int weight;
    
    Edge(int s, int e, int w) {
        this.start = s;
        this.end = e;
        this.weight = w;
    }
}

List<Edge> edges = new ArrayList<>();
edges.add(new Edge(1, 2, 8));
edges.add(new Edge(2, 5, 5));
edges.add(new Edge(1, 3, 3));
// ...
```

**최단 경로 배열 초기화**
```java
int[] dist = new int[n + 1];
Arrays.fill(dist, Integer.MAX_VALUE);
dist[start] = 0;
```

| 에지 번호 | 출발 | 도착 | 가중치 |
|----------|------|------|--------|
| 1 | 1 | 2 | 8 |
| 2 | 2 | 5 | 5 |
| 3 | 1 | 3 | 3 |
| 4 | 3 | 4 | 7 |
| 5 | 4 | 2 | -4 |
| 6 | 5 | 4 | -2 |

### 2. 모든 에지를 확인해 정답 리스트 업데이트

**반복 횟수: N - 1번** (사이클 없을 때 최대 에지 개수)

**업데이트 조건**
```java
for (int i = 0; i < n - 1; i++) {
    for (Edge edge : edges) {
        if (dist[edge.start] != Integer.MAX_VALUE &&
            dist[edge.end] > dist[edge.start] + edge.weight) {
            dist[edge.end] = dist[edge.start] + edge.weight;
        }
    }
}
```

**조건**
1. `dist[start] != ∞` (시작 노드가 무한이면 안 됨)
2. `dist[end] > dist[start] + weight` (더 짧은 경로 발견)

**동작 과정 예시**

| 반복 | 거리 배열 [1, 2, 3, 4, 5] | 업데이트 에지 |
|------|--------------------------|--------------|
| 초기 | [0, ∞, ∞, ∞, ∞] | - |
| 1회 | [0, 8, 3, ∞, ∞] | 1→2, 1→3 |
| 2회 | [0, 8, 3, 10, 13] | 3→4, 2→5 |
| 3회 | [0, 4, 3, 10, 11] | 4→2 (음수) |
| 4회 | [0, 4, 3, 9, 9] | 5→4, 2→5 |

### 3. 음수 사이클 존재 확인

**N번째 업데이트 수행**
```java
boolean hasNegativeCycle = false;
for (Edge edge : edges) {
    if (dist[edge.start] != Integer.MAX_VALUE &&
        dist[edge.end] > dist[edge.start] + edge.weight) {
        hasNegativeCycle = true;
        break;
    }
}
```

* 업데이트되는 노드 발생 → **음수 사이클 존재**
* 업데이트 없음 → 정상적인 최단 거리

## 구현 코드

```java
class BellmanFord {
    static class Edge {
        int start, end, weight;
        Edge(int s, int e, int w) {
            start = s; end = e; weight = w;
        }
    }
    
    static int n, m;
    static List<Edge> edges;
    static int[] dist;
    
    static boolean bellmanFord(int start) {
        dist = new int[n + 1];
        Arrays.fill(dist, Integer.MAX_VALUE);
        dist[start] = 0;
        
        // N-1번 반복하며 최단 거리 갱신
        for (int i = 0; i < n - 1; i++) {
            for (Edge edge : edges) {
                if (dist[edge.start] != Integer.MAX_VALUE &&
                    dist[edge.end] > dist[edge.start] + edge.weight) {
                    dist[edge.end] = dist[edge.start] + edge.weight;
                }
            }
        }
        
        // 음수 사이클 확인
        for (Edge edge : edges) {
            if (dist[edge.start] != Integer.MAX_VALUE &&
                dist[edge.end] > dist[edge.start] + edge.weight) {
                return true; // 음수 사이클 존재
            }
        }
        
        return false; // 음수 사이클 없음
    }
}
```

## 시간/공간 복잡도

| 복잡도 | 값 | 설명 |
|--------|-----|------|
| 시간 복잡도 | O(VE) | (V-1)번 × 모든 에지 확인 |
| 공간 복잡도 | O(V + E) | 거리 배열 + 에지 리스트 |

## 음수 사이클이란?

**사이클을 돌수록 가중치가 감소하는 경로**

```
A → B (가중치 5)
B → C (가중치 -3)
C → A (가중치 -4)
```
→ 사이클 합: 5 + (-3) + (-4) = -2 (음수!)
→ 무한히 돌수록 거리 감소 → **최단 거리 정의 불가**

## 장점
* 음수 가중치 에지 처리 가능
* 음수 사이클 탐지 가능
* 구현이 비교적 단순 (에지 리스트만 필요)

## 단점 및 주의사항
* 시간 복잡도 O(VE)로 느림
* 다익스트라보다 비효율적 (양수 에지만 있을 때)
* 음수 사이클 있으면 최단 거리 무의미
* Integer.MAX_VALUE 사용 시 오버플로 주의

## 사용 가이드

### 언제 사용하면 좋은가?
* **음수 가중치 에지가 존재할 때**
* **음수 사이클 탐지가 필요할 때**
* 환율 차익 거래 탐지
* 시간 여행 문제 (음수 시간)

### 언제 사용하지 말아야 하는가?
* 음수 에지가 없을 때 → **다익스트라**가 훨씬 빠름
* 모든 쌍 최단 거리 필요 → **플로이드-워셜**
* 음수 사이클이 있고 최단거리가 필요한 경우 (불가능)

## 핵심 포인트
* **N-1번 반복**: 사이클 없을 때 최대 에지 개수
* **N번째 반복**: 음수 사이클 탐지용
* **에지 리스트**: 모든 에지를 순회하기 용이
* **dist[start] != ∞ 체크**: 아직 도달 안 한 노드 제외

## 왜 N-1번 반복인가?
사이클이 없는 그래프에서 한 노드에서 다른 노드로 가는 최단 경로는 최대 N-1개의 에지를 사용하기 때문

## 그래프 초기화 예시
```java
// 에지 리스트 초기화
List<Edge> edges = new ArrayList<>();
edges.add(new Edge(1, 2, 8));
edges.add(new Edge(1, 3, 3));
edges.add(new Edge(4, 2, -4)); // 음수 가능!

// 최단 거리 배열 초기화
int[] dist = new int[n + 1];
Arrays.fill(dist, Integer.MAX_VALUE);
dist[start] = 0;
```

## 참고 자료
* 음수 사이클 문제: 타임머신, 웜홀
* 백준 벨만-포드 문제: 11657
```java
import java.io.*;
import java.util.*;

public class Main {
    static class Edge {
        int start, end, weight;

        Edge(int s, int e, int w) {
            start = s;
            end = e;
            weight = w;
        }
    }

    static int N, M;
    static List<Edge> edges;
    static long[] dist;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        N = Integer.parseInt(st.nextToken());
        M = Integer.parseInt(st.nextToken());

        edges = new ArrayList<>();

        for (int i = 0; i < M; i++) {
            st = new StringTokenizer(br.readLine());
            int s = Integer.parseInt(st.nextToken());
            int e = Integer.parseInt(st.nextToken());
            int w = Integer.parseInt(st.nextToken());

            edges.add(new Edge(s, e, w));
        }
        BellmanFord(1);
    }

    public static void BellmanFord(int start) {
        dist = new long[N + 1];
        Arrays.fill(dist, Integer.MAX_VALUE);
        dist[start] = 0;

        // N-1번 반복하며 최단거리 갱신
        for (int i = 0; i < N - 1; i++) {
            for (Edge edge : edges) {
                if (dist[edge.start] != Integer.MAX_VALUE &&
                        dist[edge.start] + edge.weight < dist[edge.end]) {
                    dist[edge.end] = dist[edge.start] + edge.weight;
                }
            }
        }

        // 음수 사이클 확인
        for (Edge edge : edges) {
            if (dist[edge.start] != Integer.MAX_VALUE &&
                    dist[edge.start] + edge.weight < dist[edge.end]) {
                System.out.println(-1);
                return;
            }
        }

        // 출력
        for (int i = 2; i <= N; i++) {
            // 경로가 없다면
            if (dist[i] == Integer.MAX_VALUE) {
                System.out.println(-1);
            } else {
                System.out.println(dist[i]);
            }
        }p  
    }
}
```
**출력 초과 원인: Integer 언더플로우**
최대 300만 번 갱신 × 음수 가중치(-10,000) = 약 -300억
→ Integer 범위 초과로 언더플로우 발생
→ dist 배열을 long으로 변경하여 해결