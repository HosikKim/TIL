# 그래프 구현 방법 3가지

## 개념
그래프를 자료구조로 표현하는 3가지 방법: 에지리스트, 인접행렬, 인접리스트

## 목적
* 그래프의 노드와 에지 관계를 효율적으로 저장
* 문제 유형에 따라 적합한 구현 방식 선택
* 시간/공간 복잡도 최적화
* 코딩 테스트에서 그래프 문제 해결

## 1. 에지리스트 (Edge List)

### 특징
배열의 행으로 에지 정보를 저장하는 방식

### 가중치 없는 그래프
```java
// 노드: 1-2-3-4-5
int[][] A = new int[2][6];
// A[0] = {1, 1, 3, 2, 2, 4};  // 시작 노드
// A[1] = {2, 3, 4, 4, 5, 5};  // 도착 노드
```

### 가중치 있는 그래프
```java
int[][] A = new int[3][6];
// A[0] = {1, 1, 3, 2, 2, 4};  // 시작 노드
// A[1] = {2, 3, 4, 4, 5, 5};  // 도착 노드
// A[2] = {8, 3, 13, 4, 15, 2}; // 가중치
```

## 2. 인접행렬 (Adjacency Matrix)

### 특징
2차원 배열로 노드 간 연결 관계를 표현

### 가중치 없는 그래프
```java
int[][] A = new int[5][5];
A[0][1] = 1;  // 1 -> 2
A[0][2] = 1;  // 1 -> 3
A[2][3] = 1;  // 3 -> 4
// ... 연결된 곳은 1로 표시
```

### 가중치 있는 그래프
```java
int[][] A = new int[5][5];
A[0][1] = 8;   // 1 -> 2 (가중치 8)
A[0][2] = 3;   // 1 -> 3 (가중치 3)
A[2][3] = 13;  // 3 -> 4 (가중치 13)
// 연결된 곳에 가중치 저장
```

## 3. 인접리스트 (Adjacency List) ★

### 특징
ArrayList를 활용한 가변 길이 리스트로 표현 (가장 선호되는 방식)

### 가중치 없는 그래프
```java
ArrayList<Integer>[] A = new ArrayList[6];
for(int i = 1; i <= 5; i++) {
    A[i] = new ArrayList<>();
}
A[1].add(2); A[1].add(3);
A[2].add(4); A[2].add(5);
A[3].add(4);
A[4].add(5);
```

### 가중치 있는 그래프 (중요!)
```java
class Node {
    int vertex;   // 도착 노드
    int weight;   // 가중치
    
    Node(int v, int w) {
        this.vertex = v;
        this.weight = w;
    }
}

ArrayList<Node>[] A = new ArrayList[6];
for(int i = 1; i <= 5; i++) {
    A[i] = new ArrayList<>();
}
A[1].add(new Node(2, 8));
A[1].add(new Node(3, 3));
A[3].add(new Node(4, 13));
// ...
```

## 구현 방법 비교표

| 구현 방법 | 에지 확인 | 노드 탐색 | 공간 복잡도 | 메모리 효율 |
|---------|----------|----------|-----------|----------|
| 에지리스트 | O(E) | O(E) | O(E) | 보통 |
| 인접행렬 | O(1) | O(N) | O(N²) | 나쁨 |
| 인접리스트 | O(degree) | O(degree) | O(N+E) | 좋음 |

## 장점

### 에지리스트
* 구현이 가장 간단함
* 에지 중심 알고리즘에 적합

### 인접행렬
* 두 노드의 연결 여부를 O(1)에 확인 가능
* 구현이 직관적

### 인접리스트
* 공간 효율성이 뛰어남 (O(N+E))
* 연결된 노드만 탐색하므로 속도 빠름
* 노드가 많아도 메모리 초과 없음

## 단점 및 주의사항

### 에지리스트
* 특정 노드와 연결된 에지 탐색이 비효율적
* 노드 중심 알고리즘에는 부적합

### 인접행렬
* 노드 개수가 많으면 메모리 낭비 심각
* 노드 3만 개 이상 시 Java Heap Space 에러 발생 가능
* 에지가 적은 희소 그래프에 비효율적

### 인접리스트
* 구현이 상대적으로 복잡함
* 두 노드의 연결 여부 확인 시 리스트 순회 필요

## 사용 가이드

### 언제 사용하면 좋은가?

**에지리스트**
* 벨만-포드 알고리즘
* 크루스칼 알고리즘 (MST)
* 에지 중심으로 처리하는 문제

**인접행렬**
* 노드 개수가 적을 때 (< 1000)
* 모든 노드 쌍의 연결 관계를 자주 확인해야 할 때
* 플로이드-워셜 알고리즘

**인접리스트 (가장 권장)**
* 코딩 테스트 대부분의 그래프 문제
* DFS, BFS 탐색
* 다익스트라 알고리즘
* 노드가 많거나 에지가 적은 경우

### 언제 사용하지 말아야 하는가?

**에지리스트**
* DFS, BFS 같은 노드 중심 탐색 알고리즘

**인접행렬**
* 노드 개수가 많을 때 (메모리 초과 위험)
* 에지가 적은 희소 그래프

**인접리스트**
* 두 노드의 연결 여부를 매우 자주 확인해야 하는 경우

## 참고 자료
* 코딩 테스트에서는 **인접리스트 + 가중치 있는 그래프** 구현이 가장 빈번함
* ArrayList 배열 선언으로 인덱스 직접 접근 가능