# 유니온-파인드 (Union-Find)

## 개념
두 노드를 하나의 집합으로 묶고(Union), 두 노드가 같은 집합에 속하는지 확인(Find)하는 알고리즘

## 목적
* 여러 노드들을 집합으로 그룹화
* 두 노드의 연결 여부 효율적으로 확인
* 그래프 문제의 부분 로직으로 활용 (사이클 판별, MST 등)
* 경로 압축을 통한 시간 복잡도 최적화

## 핵심 연산

### Union 연산
특정 2개의 노드를 연결하여 1개의 집합으로 묶는 연산

**핵심 원칙**: 항상 **대표 노드끼리 연결**

```java
static void union(int a, int b) {
    a = find(a);  // a의 대표 노드 찾기
    b = find(b);  // b의 대표 노드 찾기
    if (a != b) {
        parent[b] = a;  // b의 대표를 a로 변경
    }
}
```

### Find 연산
자신이 속한 집합의 대표 노드를 찾는 연산

**핵심 기능**: 대표 노드 찾기 + **경로 압축**

```java
static int find(int x) {
    if (parent[x] == x) {
        return x;  // 자기 자신이 대표 노드
    }
    // 경로 압축: 재귀에서 돌아오며 대표 노드로 갱신
    return parent[x] = find(parent[x]);
}
```

## 동작 원리

### 1. 초기화
```java
int[] parent = new int[n + 1];
for (int i = 1; i <= n; i++) {
    parent[i] = i;  // 자기 자신을 대표 노드로 초기화
}
```

| 인덱스 | 1 | 2 | 3 | 4 | 5 | 6 |
|-------|---|---|---|---|---|---|
| 값    | 1 | 2 | 3 | 4 | 5 | 6 |

### 2. Union 연산 과정

**union(1, 4) 실행**
- find(1) = 1, find(4) = 4
- parent[4] = 1

**union(5, 6) 실행**
- find(5) = 5, find(6) = 6
- parent[6] = 5

**union(4, 6) 실행 (중요!)**
- find(4) = 1 (4의 대표는 1)
- find(6) = 5 (6의 대표는 5)
- parent[5] = 1 (대표 노드끼리 연결)
- 결과: 1-4-6이 모두 같은 집합

### 3. Find 연산과 경로 압축

**경로 압축 전 그래프 (1-2-3-4-5-6)**
```
1 → 2 → 3 → 4 → 5 → 6
```

**find(6) 실행 시**
1. parent[6] != 6 → find(parent[6]) = find(5)
2. parent[5] != 5 → find(parent[5]) = find(4)
3. ... (재귀 계속)
4. parent[1] == 1 → return 1
5. **재귀에서 빠져나오며**: parent[5]=1, parent[6]=1 갱신

**경로 압축 후 그래프 (별 모양)**
```
    2   3   4   5   6
     \  |  /  /  /
         1
```

## 완전한 구현 코드

```java
class UnionFind {
    static int[] parent;
    
    // 초기화
    public static void init(int n) {
        parent = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            parent[i] = i;
        }
    }
    
    // Find 연산 (경로 압축 포함)
    public static int find(int x) {
        if (parent[x] == x) return x;
        return parent[x] = find(parent[x]);
    }
    
    // Union 연산
    public static void union(int a, int b) {
        a = find(a);
        b = find(b);
        if (a != b) {
            parent[b] = a;
        }
    }
    
    // 같은 집합인지 확인
    public static boolean isSameSet(int a, int b) {
        return find(a) == find(b);
    }
}
```

## 시간 복잡도

| 연산 | 경로 압축 없이 | 경로 압축 적용 |
|-----|-------------|-------------|
| Find | O(N) | O(α(N)) ≈ O(1) |
| Union | O(N) | O(α(N)) ≈ O(1) |

* α(N): 아커만 함수의 역함수 (매우 느리게 증가, 거의 상수)
* 경로 압축으로 그래프가 평탄화되어 Find 속도 대폭 향상

## 장점
* 구현이 간단함 (20줄 내외)
* 경로 압축 시 거의 O(1)의 빠른 속도
* 메모리 효율적 (1차원 배열만 사용)
* 동적으로 집합 관리 가능

## 주의사항
* Union 연산 시 반드시 **대표 노드끼리 연결**해야 함
* Find 연산 시 **경로 압축을 반드시 구현**해야 효율적
* parent 배열 인덱스와 노드 번호 일치시켜야 함
* 초기화를 잊지 말 것

## 사용 가이드

### 언제 사용하면 좋은가?
* **사이클 판별**: 무방향 그래프에서 사이클 존재 확인
* **크루스칼 알고리즘**: 최소 신장 트리(MST) 구현
* **집합 연결 상태 확인**: 두 노드가 같은 그룹인지 판별
* **네트워크 연결성**: 컴퓨터 네트워크, 도로망 연결 확인

### 대표적인 문제 유형
* "집합 연결하기" - 여러 원소를 그룹으로 묶기
* "친구 네트워크" - 친구 관계로 연결된 그룹 찾기
* "도시 연결" - 도시들이 연결되어 있는지 확인
* "최소 비용으로 모든 도시 연결" - MST 문제

### 언제 사용하지 말아야 하는가?
* 방향 그래프의 연결성 확인 (DFS/BFS 사용)
* 최단 경로 찾기 (다익스트라 등 사용)
* 경로 자체가 필요한 경우 (경로 정보 저장 안 됨)

## 참고 자료
* Union-Find는 **Disjoint Set**(서로소 집합)이라고도 불림
* 백준 유니온-파인드 문제 : 1976(여행가자)
```java
import java.io.*;
import java.util.*;

public class Main {
    static int[] parent;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        // 도시 수
        int N = Integer.parseInt(br.readLine());
        // 여행 계획 도시 수
        int M = Integer.parseInt(br.readLine());

        init(N);

        // union 처리
        for (int i = 1; i <= N; i++) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            for (int j = 1; j <= N; j++) {
                int connected = Integer.parseInt(st.nextToken());
                if (connected == 1) {
                    union(i, j);
                }
            }
        }

        // 여행 계획 읽기
        int[] plan = new int[M];
        StringTokenizer st = new StringTokenizer(br.readLine());
        for (int i = 0; i < M; i++) {
            plan[i] = Integer.parseInt(st.nextToken());
        }

        boolean possible = true;
        for (int i = 0; i + 1 < M; i++) {
            if (!isSameSet(plan[i], plan[i + 1]))
                possible = false;

        }

        System.out.println(possible ? "YES" : "NO");

    }

    static void init(int n) {
        parent = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            parent[i] = i;
        }
    }

    static int find(int x) {
        if (parent[x] == x)
            return x;
        return parent[x] = find(parent[x]);
    }

    static void union(int a, int b) {
        a = find(a);
        b = find(b);
        if (a != b) {
            parent[b] = a;
        }
    }

    static boolean isSameSet(int a, int b) {
        return find(a) == find(b);
    }
}

```