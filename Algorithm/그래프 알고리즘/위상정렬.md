# 위상정렬 (Topological Sort)

## 개념
사이클이 없는 방향 그래프(DAG)에서 노드의 순서를 찾는 알고리즘

## 목적
* 선후 관계가 있는 작업들의 순서 결정
* 의존성이 있는 작업의 실행 순서 찾기
* 선수과목, 빌드 순서 등의 문제 해결
* 사이클 존재 여부 확인

## 핵심 개념: 진입 차수 (Indegree)

**자기 자신을 가리키는 에지의 개수**

```java
// 에지 추가 시 진입 차수 계산
graph[1].add(2); indegree[2]++;
graph[1].add(3); indegree[3]++;
```

| 노드 | 1 | 2 | 3 | 4 | 5 |
|-----|---|---|---|---|---|
| 진입차수 | 0 | 1 | 1 | 2 | 2 |

## 구현 방법

```java
static List<Integer> topologicalSort() {
    Queue<Integer> queue = new LinkedList<>();
    List<Integer> result = new ArrayList<>();
    
    // 1. 진입차수 0인 노드 큐에 추가
    for (int i = 1; i <= n; i++) {
        if (indegree[i] == 0) {
            queue.offer(i);
        }
    }
    
    // 2. 큐가 빌 때까지 반복
    while (!queue.isEmpty()) {
        int now = queue.poll();
        result.add(now);
        
        // 3. 연결된 노드의 진입차수 감소
        for (int next : graph[now]) {
            indegree[next]--;
            if (indegree[next] == 0) {
                queue.offer(next);
            }
        }
    }
    
    // 4. 사이클 확인
    if (result.size() != n) {
        return null; // 사이클 존재
    }
    
    return result;
}
```

## 동작 과정

| 단계 | 설명 | 비고 |
|------|------|------|
| 초기화 | 진입차수 배열 계산 | 모든 노드 순회 |
| 시작 | 진입차수 0인 노드 큐에 추가 | 시작 가능한 노드 |
| 반복 | 노드 처리 → 진입차수 감소 → 0이면 큐 추가 | 큐가 빌 때까지 |
| 완료 | 정렬된 순서 반환 | result 크기로 사이클 확인 |

## 시간/공간 복잡도

| 복잡도 | 값 | 설명 |
|--------|-----|------|
| 시간 복잡도 | O(V + E) | 모든 노드와 에지를 한 번씩 확인 |
| 공간 복잡도 | O(V) | 진입차수 배열 + 큐 |

## 중요 특징

| 특징 | 설명 |
|------|------|
| DAG 전용 | 사이클 없는 방향 그래프에서만 동작 |
| 비유일성 | 정렬 결과가 여러 개일 수 있음 |
| 사이클 탐지 | result.size() != n이면 사이클 존재 |

## 장점
* 구현이 간단함 (큐 사용)
* O(V+E)로 효율적
* 사이클 탐지 가능

## 단점 및 주의사항
* **사이클 존재 시 동작 불가**
* 정렬 결과가 유일하지 않을 수 있음
* 방향 그래프 전용
* 진입차수 배열 초기화 필수

## 사용 가이드

### 언제 사용하면 좋은가?
* 선수과목 문제
* 빌드/컴파일 순서
* 작업 스케줄링 (선후 관계)
* 패키지 의존성 해결

### 언제 사용하지 말아야 하는가?
* 사이클 존재하는 그래프
* 무방향 그래프
* 최단 경로 필요 시
* 유일한 순서 보장 필요 시

## 그래프 초기화 예시
```java
// 인접 리스트 + 진입차수 배열
ArrayList<Integer>[] graph = new ArrayList[n + 1];
int[] indegree = new int[n + 1];

for (int i = 1; i <= n; i++) {
    graph[i] = new ArrayList<>();
}

// 에지 추가
graph[a].add(b);
indegree[b]++;
```

## 참고 자료
* 진입차수가 핵심
* 백준 위상정렬 문제: 2252(줄 세우기)
```java
import java.io.*;
import java.util.*;

public class Main {

    static int N, M;
    static List<Integer>[] graph;
    static int[] indegree;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        N = Integer.parseInt(st.nextToken());
        M = Integer.parseInt(st.nextToken());

        graph = new ArrayList[N + 1];
        indegree = new int[N + 1];

        for (int i = 1; i <= N; i++) {
            graph[i] = new ArrayList<>();
        }

        for (int i = 0; i < M; i++) {
            st = new StringTokenizer(br.readLine());
            int A = Integer.parseInt(st.nextToken());
            int B = Integer.parseInt(st.nextToken());
            graph[A].add(B);
            indegree[B]++;
        }

        sort();
    }

    static void sort() {
        Queue<Integer> queue = new LinkedList<>();

        for (int i = 1; i <= N; i++) {
            // 진입차수가 0이라면 큐에 담기
            if (indegree[i] == 0) {
                queue.offer(i);
            }
        }

        // List는 문자열 변환 과정이 필요하고 메모리를 더 사용 함
        // 출력만 하면 되기에 StringBuilder가 빠름
        StringBuilder result = new StringBuilder();

        while (!queue.isEmpty()) {
            int now = queue.poll();
            result.append(now).append(" ");

            for (int next : graph[now]) {
                // 선택된 노드가 가리키는 진입 차수를 1씩 뺌
                indegree[next]--;
                if (indegree[next] == 0) {
                    queue.offer(next);
                }
            }
        }
        System.out.println(result);
    }
}

```
