# 이진 탐색 (Binary Search)

## 개념
정렬된 데이터에서 중앙값 비교를 통해 탐색 범위를 절반씩 줄여가며 원하는 값을 찾는 알고리즘

## 목적
* 정렬된 대량 데이터에서 빠른 탐색 제공
* 선형 탐색(O(N))보다 효율적인 탐색 구현
* 데이터베이스 인덱스, 검색 시스템 등에 활용

## 필수 조건
 **데이터가 반드시 정렬되어 있어야 함** (오름차순 또는 내림차순)

## 동작 원리

### 핵심 4단계 프로세스
1. 현재 데이터셋에서 **중앙값 선택**
2. 중앙값 > 타깃 → **왼쪽 데이터셋** 선택
3. 중앙값 < 타깃 → **오른쪽 데이터셋** 선택
4. 중앙값 == 타깃 → **탐색 종료**

### 동작 예시

**데이터**: `[3, 7, 13, 15, 23, 35, 38, 41, 46, 49, 55, 67, 68, 72, 77, 86]`  
**타깃**: `55`

| 단계 | 탐색 범위 | 중앙값 | 비교 결과 | 다음 동작 |
|------|-----------|--------|-----------|-----------|
| 1 | 전체 데이터 (16개) | 41 | 41 < 55 | 오른쪽으로 이동 |
| 2 | [46, 49, 55, 67, 68, 72, 77, 86] | 67 | 67 > 55 | 왼쪽으로 이동 |
| 3 | [46, 49, 55] | 49 | 49 < 55 | 오른쪽으로 이동 |
| 4 | [55] | 55 | 55 == 55 | ✅ 탐색 성공 |

## 시간 복잡도

| 상황 | 복잡도 | 설명 |
|------|--------|------|
| 최선 | O(1) | 첫 비교에서 타깃 발견 |
| 평균 | O(log N) | 매번 범위가 절반으로 축소 |
| 최악 | O(log N) | 끝까지 탐색해도 log N |

**공간 복잡도**: O(1) (반복문 구현 시)

## 구현 방법

### 반복문 구현
```java
int binarySearch(int[] arr, int target) {
    int left = 0;
    int right = arr.length - 1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] == target) return mid;
        else if (arr[mid] < target) left = mid + 1;
        else right = mid - 1;
    }
    return -1; // 찾지 못함
}
```

## 장점
* 매우 빠른 탐색 속도 (O(log N))
* 대용량 데이터에서도 효율적
* 구현이 비교적 간단

## 주의사항
* **정렬되지 않은 데이터에서는 사용 불가**
* 정렬 비용(O(N log N))을 고려해야 함
* 중앙값 계산 시 오버플로우 주의: `(left + right) / 2` 대신 `left + (right - left) / 2` 사용

## 사용 가이드

### 언제 사용하면 좋은가?
* 정렬된 배열/리스트에서 특정 값 찾기
* 범위 탐색 문제 (Lower Bound, Upper Bound)
* 최적화 문제 (파라메트릭 서치)

### 언제 사용하지 말아야 하는가?
* 데이터가 정렬되어 있지 않을 때
* 데이터 개수가 매우 적을 때 (N < 10)
* 연결 리스트처럼 인덱스 접근이 느린 자료구조

## 참고 자료
* Java: `Arrays.binarySearch()`
* Python: `bisect` 모듈
* 백준 이진탐색 문제: 2805

```java
package Algorithm;

import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        // 1. 입력 받기
        StringTokenizer st = new StringTokenizer(br.readLine());
        int N = Integer.parseInt(st.nextToken());
        int M = Integer.parseInt(st.nextToken());

        int[] trees = new int[N];
        st = new StringTokenizer(br.readLine());

        int maxheight = 0;
        for (int i = 0; i < N; i++) {
            trees[i] = Integer.parseInt(st.nextToken());
            if (trees[i] > maxheight) {
                maxheight = trees[i];
            }
        }

        // 2. 이진탐색 범위 설정
        long left = 0;
        long right = maxheight;
        long answer = 0;

        // 3. 이진탐색
        while (left <= right) {
            long mid = (left + right) / 2;
            // System.out.println("left=" + left + ", right=" + right + ", mid" + mid);

            long sum = calc(trees, mid);
            // System.out.println("sum=" + sum + ", M=" + M);
            if (sum >= M) {
                answer = mid;
                // System.out.println("조건만족, answer 값: " + answer);
                left = mid + 1;
            } else {
                // System.out.println("sum<M, 높이낮춤");
                right = mid - 1;
            }
        }
        System.out.println(answer);
    }

    static long calc(int[] trees, long height) {
        long sum = 0;

        for (int tree : trees) {
            if (height < tree) {
                sum += tree - height;
            }
        }

        return sum;
    }
}

```