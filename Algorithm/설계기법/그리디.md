# 그리디 알고리즘 (Greedy Algorithm)

## 개념
현재 상태에서 가장 최선의 선택을 반복하여 최종 해를 구하는 알고리즘

## 핵심 특징
* **매 선택마다 지역 최적해(local optimal)를 선택**
* 지역 최적해가 전역 최적해(global optimal)라고 **가정**
* 모든 문제에서 최적해를 보장하지 않음
* 빠른 수행 시간 (일반적으로 O(n) ~ O(n log n))

## 수행 과정

```
1. 해 선택 (Selection)
   → 현재 상태에서 가장 최선이라고 생각되는 해를 선택

2. 적절성 검사 (Feasibility Check)
   → 선택한 해가 문제의 제약조건에 벗어나지 않는지 검사

3. 해 검사 (Solution Check)
   → 현재까지 선택한 해 집합이 문제를 해결할 수 있는지 검사
   → 해결되지 않았다면 1번으로 돌아가기
```

## 적용 가능 조건

| 조건 | 설명 |
|------|------|
| **탐욕적 선택 속성** | 각 단계의 지역 최적해가 전역 최적해로 이어져야 함 |
| **최적 부분 구조** | 문제의 최적해가 부분 문제의 최적해로 구성되어야 함 |

## 장점
* 구현이 간단하고 직관적
* 수행 시간이 빠름
* 메모리 사용량이 적음

## 단점 및 주의사항
* **최적해를 보장하지 않음**
* 문제에 따라 적용 불가능한 경우가 많음
* 반례가 존재하는지 반드시 검증 필요

## 대표 문제 유형

| 문제 | 그리디 전략 | 최적해 보장 |
|------|------------|-----------|
| 거스름돈 | 큰 단위부터 선택 | ⭕ (특정 화폐 체계) |
| 회의실 배정 | 끝나는 시간 빠른 순 | ⭕ |
| 배낭 문제 (Fractional) | 단위당 가치 높은 순 | ⭕ |
| 배낭 문제 (0/1) | - | ❌ (DP 필요) |
| 최소 신장 트리 | Kruskal, Prim | ⭕ |

## 사용 가이드

### 언제 사용하면 좋은가?
* 문제가 탐욕적 선택 속성과 최적 부분 구조를 만족할 때
* 정렬 후 순차적으로 선택하면 되는 문제
* 빠른 근사해가 필요한 경우

### 언제 사용하지 말아야 하는가?
* 이전 선택이 이후 선택에 영향을 주는 경우
* 반례가 존재하는 경우
* 정확한 최적해가 필수인 경우 (→ DP, 완전탐색 고려)

## 검증 방법
1. **반례 찾기**: 그리디로 풀었을 때 최적해가 아닌 케이스 확인
2. **수학적 증명**: 귀류법, 교환 논증(exchange argument) 활용
3. **다른 알고리즘과 비교**: DP 등으로 검증

## 참고 자료
* 백준 주요 그리디 문제: 1931(회의실)

* 정렬 후 현재 값이 최선이라고 가정

```java
import java.util.*;
import java.io.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        int n = Integer.parseInt(br.readLine());
        // 시작시간, 끝시간을 담을 2차원 배열
        int[][] meets = new int[n][2];

        for (int i = 0; i < n; i++) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            meets[i][0] = Integer.parseInt(st.nextToken());
            meets[i][1] = Integer.parseInt(st.nextToken());
        }

        // 정렬
        // 끝 시간을 기준으로 오름차순
        // 끝 시간이 같다면 시작시간을 기준으로 오름차순
        Arrays.sort(meets, (a, b) -> {
            if (a[1] != b[1]) {
                return a[1] - b[1];
            } else {
                return a[0] - b[0];
            }
        });

        // 회의 선택
        int count = 0;
        int endTime = 0;

        for (int i = 0; i < n; i++) {
            int start = meets[i][0];
            int end = meets[i][1];

            if (start >= endTime) {
                endTime = end;
                count++;
            }
        }

        System.out.println(count);
    }
}

```