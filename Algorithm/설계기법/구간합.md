# 구간합 (Prefix Sum)

## 개념
배열의 특정 구간의 합을 빠르게 계산하기 위해 누적 합을 미리 저장하는 알고리즘

## 목적
* 반복적인 구간합 계산 시 시간복잡도를 O(N)에서 O(1)로 단축
* 여러 구간에 대한 합을 빠르게 구할 때 유용
* 메모리를 추가로 사용하여 시간을 절약하는 트레이드오프

## 핵심 원리

### 1. 합배열(S) 생성
```java
S[i] = S[i-1] + A[i]
```
- `S[i]`: A[0]부터 A[i]까지의 모든 원소의 합
- 배열을 한 번 순회하며 누적합 저장

### 2. 구간합 계산
```java
// i부터 j까지의 구간합
구간합 = S[j] - S[i-1]
```
- 미리 계산된 합배열로 O(1)에 구간합 계산 가능

## 구체적 예시

### 원본 배열 A
| 인덱스 | 0 | 1 | 2 | 3 | 4 | 5 |
|--------|---|---|---|---|---|---|
| 값     | 15| 13| 10| 7 | 3 | 12|

### 합배열 S
| 인덱스 | 0 | 1 | 2 | 3 | 4 | 5 |
|--------|---|---|---|---|---|---|
| 누적합 | 15| 28| 38| 45| 48| 60|

### 구간합 계산 예시
**인덱스 2~5까지의 합을 구하려면?**
```
S[5] - S[1] = 60 - 28 = 32
→ A[2] + A[3] + A[4] + A[5] = 10 + 7 + 3 + 12 = 32
```

## 시간복잡도 비교

| 방법 | 전처리 | 구간합 계산 | 총 시간 (Q번 쿼리) |
|------|--------|-------------|-------------------|
| 일반 반복문 | - | O(N) | O(N × Q) |
| 구간합 | O(N) | O(1) | O(N + Q) |

## 구현 코드

```java
// 합배열 생성
int[] S = new int[n];
S[0] = A[0];
for (int i = 1; i < n; i++) {
    S[i] = S[i-1] + A[i];
}

// 구간합 계산 (i부터 j까지)
int sum = S[j] - (i > 0 ? S[i-1] : 0);
```

## 사용 가이드

### 언제 사용하면 좋은가?
* 동일한 배열에 대해 여러 번 구간합을 구해야 할 때
* 구간 쿼리가 많은 문제 (Q ≥ 100)
* 2차원 배열의 부분 합 계산 (2D Prefix Sum으로 확장 가능)

### 언제 사용하지 말아야 하는가?
* 구간합을 단 한 번만 구하는 경우
* 배열이 자주 업데이트되는 경우 (세그먼트 트리 고려)
* 메모리 제약이 매우 심한 경우

## 주의사항
* 인덱스 0일 때 `i-1`이 음수가 되지 않도록 처리 필요
* 오버플로우 주의 (합이 큰 경우 long 타입 사용)
