# 백트래킹 (Backtracking)

## 개념
문제 해결 경로를 탐색하다가 유효하지 않으면 이전 단계로 되돌아가 다른 경로를 시도하는 알고리즘

## 목적
* 모든 가능한 경로를 체계적으로 탐색
* 불필요한 탐색을 조기에 차단 (가지치기)
* 완전 탐색보다 효율적으로 해를 찾기
* 제약 조건이 있는 조합/순열 문제 해결

## 시간/공간 복잡도

| 복잡도 | 표기 | 설명 |
|--------|------|------|
| 시간 복잡도 | O(N^d) | N: 분기 수, d: 탐색 깊이 |
| 공간 복잡도 | O(d) | 재귀 호출 스택 깊이만큼 |

## 수행 과정

```
1. 가능한 선택지 탐색
   → 현재 상태에서 선택할 수 있는 모든 후보를 확인

2. 유효성 검사 및 가지치기
   → 조건을 만족하지 않는 경로는 더 이상 탐색하지 않고 제거

3. 해답 도출
   → 조건을 만족하는 완전한 해를 찾거나, 모든 경로 탐색 완료
```

## 가지치기 (Pruning) 예시

```
목표: 합이 50이 되는 조합 찾기
시작 노드: 10

       10
      /  \
     7    45  ← 10+45=55 > 50 (가지치기!)
    / \
  ...  ...  ← 왼쪽만 계속 탐색
```

**핵심**: 45를 선택하는 순간 이미 목표값 50을 초과하므로, 오른쪽 서브트리 전체를 탐색하지 않음

## 구현 특징

| 항목 | 설명 |
|------|------|
| 구현 방식 | 재귀 함수 |
| 핵심 메커니즘 | 선택 → 검증 → 재귀 → 복원 |
| 성능 향상 | 가지치기로 불필요한 탐색 제거 |

## 백트래킹 vs DFS

| 구분 | 백트래킹 | DFS |
|------|----------|-----|
| 목적 | 조건을 만족하는 해 찾기 | 모든 노드 방문 |
| 가지치기 | 적극 사용 | 사용 안 함 |
| 효율성 | 조건부 탐색으로 효율적 | 모든 경로 탐색 |

## 사용 가이드

### 언제 사용하면 좋은가?
* N-Queen, 스도쿠 등 제약 조건 문제
* 조합/순열 생성 (특정 조건 만족)
* 부분집합 합 문제
* 미로 찾기, 경로 탐색

### 주의사항
* 최악의 경우 모든 경우를 탐색 (지수 시간)
* 가지치기 조건을 명확히 설정해야 성능 향상
* 재귀 깊이가 깊으면 스택 오버플로우 위험

## 참고 자료
* 대표 문제: N-Queen, 스도쿠, 부분집합의 합
* 백준 주요 백트래킹 문제: 15649(N과 M)
```java
import java.util.Scanner;

public class Main {
    static int N, M;
    static int[] S;
    static boolean[] V;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        N = sc.nextInt();
        M = sc.nextInt();

        S = new int[M];
        V = new boolean[N + 1];

        backtracking(0);
    }

    static void backtracking(int len) {
        if (len == M) {
            for (int i = 0; i < M; i++) {
                System.out.print(S[i] + " ");
            }
            System.out.println();
            return;
        }
        for (int i = 1; i <= N; i++) {
            // 백트래킹의 가지치기 기법
            if (V[i] == true) {
                continue;
            } else {
                V[i] = true;
                S[len] = i;
                // 재귀 형식으로 구현
                backtracking(len + 1);
                V[i] = false;
            }
        }
    }
}
```